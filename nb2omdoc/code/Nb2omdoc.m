(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)



Off[General::spell,General::spell1]
Off[General::stop]
Needs["Automata`automata`"]
Get["Automata`experimental`"]



















Clear[InitializeCounters,genID]

$leerzeichen = 1;
$ostream;
$filename = "";
$indent = 0;
$deltaindent = 1;

InitializeCounters[] := 
(
	$tmpcnt = 0;
	$indent = 0;
	codeCnt = 0;
	textCnt = 0;
	groupCnt = 0;
	inputCnt = 0;
	sectionCnt = 0;
	ssectionCnt = 0;
	sssectionCnt = 0;
	ssssectionCnt = 0;
	titleCnt = 0;
	stitleCnt = 0;
	sstitleCnt = 0;
	theoremCnt = 0;
	definitionCnt = 0;
	propositionCnt = 0;
	lemmaCnt = 0;
	corollaryCnt = 0;
	commentCnt = 0;
	exerciseCnt = 0;
	exampleCnt = 0;
	questionCnt = 0;
	proofCnt = 0;	
	proofstepCnt = 0;	
	globalCnt = 0;
	mtainCnt = 0;
	mtaoutCnt = 0;
	graphCnt = 0;
);

genID["text"] :=  "T" <> ToString[ textCnt++]
genID["title"] :=  "S" <> ToString[ titleCnt++]
genID["subtitle"] :=  "S" <> ToString[ stitleCnt++]
genID["subsubtitle"] :=  "S" <> ToString[ sstitleCnt++]
genID["section"] :=  "S" <> ToString[ sectionCnt++]
genID["subsection"] :=  "S" <> ToString[ ssectionCnt++]
genID["subsubsection"] :=  "S" <> ToString[ sssectionCnt++]
genID["subsubsubsection"] :=  "S" <> ToString[ ssssectionCnt++]
genID["omgroup"] :=  "G" <> ToString[ groupCnt++]
genID["theorem"] :=  "Thm" <> ToString[ theoremCnt++]
genID["lemma"] :=  "L" <> ToString[ lemmaCnt++]
genID["proposition"] :=  "P" <> ToString[ propositionCnt++]
genID["corollary"] :=  "O" <> ToString[ corollaryCnt++]
genID["definition"] :=  "D" <> ToString[ definitionCnt++]
genID["comment"] :=  "C" <> ToString[ commentCnt++]
genID["example"] :=  "E" <> ToString[ exampleCnt++]
genID["exercise"] :=  "X" <> ToString[ exerciseCnt++]
genID["proof"] :=  "Pr" <> ToString[ proofCnt++]
genID["proofstep"] :=  "Ps" <> ToString[ proofstepCnt++]
genID["mtainput"] :=  "Mtain" <> ToString[ matinputCnt++]
genID["code"] :=  "c" <> ToString[ codeCnt++]

$tracemath = False;
$fulltracemath=False;
$traceinput = False;
$traceoutput = False;
$fulltrace = False;
$longpath = True;




Clear[WriteText,WriteTextNL,WriteTextBrck,WriteTextBrckNL,WriteElt]

WriteTextBrckNL[ str__String ] := 
  WriteString[  $ostream,"<",str,">\n" ]

WriteTextBrck[  str__String ] := 
  WriteString[  $ostream,"<",str,">" ]

WriteTextNL[ str__String ] := 
  WriteString[  $ostream,makeSpace[] , str,"\n" ]

WriteTextNLNone[ str_String ] := 
  WriteString[  $ostream,makeSpace[] , ToString[ str,InputForm],"\n" ]

WriteTextNLNone[str_String]:=WriteString[$ostream,makeSpace[],str,"\n"]

WriteText[  str_String ] := 
  WriteString[  $ostream,makeSpace[] <> str ]

WriteTextNL[ StyleBox[str_String,___] ] := 
  WriteString[  $ostream,makeSpace[] , str,"\n" ]

WriteText[  StyleBox[str_String,___] ] := 
  WriteString[  $ostream,makeSpace[] <> str ]

makeSpace[] := StringJoin@@Table[" ",{$indent} ]

WriteTextNLNI[ str_String ] := 
    With[  {indnl = "\n" <> makeSpace[]},
      WriteString[  $ostream,makeSpace[], 
        StringReplace[str, "\n"\[Rule]indnl ],"\n" ] ];

WriteBElt[ str_String, atts___ ] := 
    ( 
      	WriteText[ "<"<>str ];
      	LL = Partition[{atts},2];
      	Map[ printAttPairs, LL ];
      	WriteString[ $ostream,">\n" ];
      	$indent += $deltaindent;
      );

printAttPairs[ {a_String,b_String} ] := 
    	 WriteString[ $ostream, " ", a , "=\"", b , "\"" ];

WriteEElt[ str_String ] := 
    (
      	$indent -= $deltaindent;
      	WriteTextNL[  "</"<>str<>">" ];
      );

WriteElt[ str_String, atts___ ] := 
    ( 
      	WriteText[ "<"<>str ];
      	LL = Partition[{atts},2];
      	Map[ printAttPairs, LL ];
      	WriteString[ $ostream,"/>\n" ];
      );


WriteOMS[ str_String ] := 
    	 WriteString[ $ostream, makeSpace[],"<OMS cd=\"dummy\" name=\"", str,
      "\"/>\n" ];




ClearAll[WriteCDATA]
WriteCDATA[str_String ] := 
  (
    	WriteTextNL["<![CDATA[" <> str <> "]]>"];
    )

ClearAll[WriteCMP]

WriteCMP[str_String, atts___ ] := 
  (
         WriteBElt["CMP", atts ];
    	WriteTextNLNone[str];
    	WriteEElt["CMP"];
    )

WriteCMP[TextData[L_List],atts___ ] := 
  (
         WriteBElt["CMP",atts ];
        Map[ ProcessText, L ];
    	WriteEElt["CMP"];
    )

WriteCMP[TextData[bx_],atts___ ] := 
  (
         WriteBElt["CMP",atts ];
        ProcessText[bx];
    	WriteEElt["CMP"];
    )



Clear[CellType]
CellType[ Cell[_,ct_String,___]] := ct;
CellType[ Cell[___]] := "***";

ClearAll[CellCont]
CellCont[ Cell[cnt_,___ ]] := cnt;



ClearAll[NB2OMDoc]

NB2OMDoc::nofile = "cannot open `1`";
NB2OMDoc::nodir  = "cannot cd to `1`";
NB2OMDoc::nosave = "cannot save `1`";
NB2OMDoc::noclose = "cannot close `1`";

NB2OMDoc[ nbpath_String,fn_String ]:=
    Module[{cepos,i,nbp, nb },
      
      	InitializeCounters[];
      
      
      	If[ StringMatchQ[ fn, "*.nb" ],
        		filename = fn; 
        		$filename = StringDrop[fn,-3], 
        		filename = StringJoin[fn,".nb"];
        		$filename = fn
        	];
      
      Print["nb2omdoc:  ",filename  ];
      
      	If[(nb=(Get[ToFileName[nbpath,filename]]))===$Failed,
        			Message[NB2OMDoc::nofile,filename] ;
        			Return[]
        	];
      (*
        	$ostream = OpenWrite[ StringJoin[$filename,".omdoc"],
              				CharacterEncoding\[Rule]None ];
        *)
      
      	$ostream = OpenWrite[ StringJoin[$filename,".omdoc"]];
      
      	printHeader[$filename];
      	ProcessNotebook[ nb ] ;
      	printFooter[];
      
      	If[ NotebookClose[nb]===$Failed,
        		Message[NB2OMDoc::noclose,filename] ;
        			Return[]
        	];
      
      	Close[$ostream];
      ];

printHeader[  s_String ] := 
    ( 
      	WriteTextBrckNL[ "?xml version=\"1.0\"?"];
      
      If[$longpath,
        	WriteTextBrckNL[ 
          "!DOCTYPE omdoc SYSTEM \"../../../../../../omdoc/dtd/omdoc.dtd\" \
[]"],
        	WriteTextBrckNL[ "!DOCTYPE omdoc SYSTEM \"omdoc.dtd\" []"]
        ]; 
      	WriteTextNL[ "<omdoc id=\"" <> s <>"-omdoc\"" ];
      	WriteTextNL[ "xmlns=\"http://www.mathweb.org/omdoc\"" ];
      	WriteTextNL[ 
        "catalogue=\"../../../../../../omdoc/examples/omstd/catalogue.omdoc\"\
" ];
      	WriteTextNL[ 
        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""];
      	WriteTextNL[ 
        "xsi:schemaLocation=\"omdoc.xsd http://www.mathweb.org/omdoc\">" ]; 
      );

printFooter[] :=  WriteTextBrckNL[ "/omdoc"];







ClearAll[ProcessCell]

ClearAll[ProcessNotebook]
ProcessNotebook[nb:Notebook[ {cells__},options___ ]] :=  
  Module[ {cc,cnt},
    	cc = {cells};
    	cnt = 1;
    	WriteBElt["metadata"];
    	If[  CellType[cc[[cnt]]] \[Equal] "Title",
      		WriteBElt["Title"];
      			ProcessText[CellCont[cc[[cnt]]]];
      		WriteEElt["Title"];
      		cnt++ ];
    	If[  CellType[cc[[cnt]]] \[Equal] "Creator",
      		WriteBElt["Creator"];
      			ProcessText[CellCont[cc[[cnt]]]];
      		WriteEElt["Creator"];
      		cnt++ ];
    	If[  CellType[cc[[cnt]]] \[Equal] "Date",
      		WriteBElt["Date"];
      			ProcessText[CellCont[cc[[cnt]]]];
      		WriteEElt["Date"];
      		cnt++ ];
    	WriteEElt["metadata"];
    
    	WriteBElt["catalogue"];
    	WriteTextBrckNL[
      "loc theory=\"symbols\" \
omdoc=\"../../../../../theories/migration/symbols.omdoc\" /"];
    	WriteTextBrckNL[
      "loc theory=\"scripts\" \
omdoc=\"../../../../../theories/migration/scripts.omdoc\" /"];
    
    	WriteEElt["catalogue"];
    		
    	Map[ ProcessCell, Drop[cc,cnt-1] ];
    ] 





ProcessCell[ Cell[cont_] ] := ProcessCell[cont];
ProcessCell[ Cell[cont_, Open|Closed\.18\.13] ] := ProcessCell[cont];



ProcessCell[ Cell[CellGroupData[ {hdc_,rest___},___] ]] := 
  (
    	ProcessGroupHeader[hdc];
    	Map[ ProcessCell, {rest} ];
    	WriteEElt["omgroup" ];
    )



$headingsm={"Section","Subsection","Subsubsection","Subsubsubsection","Title",
      "Subtitle","Subsubtitle"};

$headingsx={"Section","Subsection","Subsubsection","Subsubsubsection","Title",
      "Subtitle","Subsubtitle"};

$headingsx=Table[ "Title",{7}];

AssignFunction[ transH, $headingsm, $headingsx ] 

isHeading[str_String] := MemberQ[ $headingsm, str ];

ProcessGroupHeader[  Cell[cont_,hd_?isHeading,___] ] := 
    (
      	WriteBElt["omgroup","id",genID["omgroup"]];
      	WriteDCTitle[ cont,transH[hd]];
      );

WriteDCTitle[  str_String,hd_String ] := 
    (
      	WriteBElt["metadata"];
      	WriteBElt[hd];
      	WriteTextNL[ str];
      	WriteEElt[hd];
      	WriteEElt["metadata"];
      );

WriteDCTitle[ TextData[L_List,___], hd_String ] := 
    (
      	WriteBElt["metadata"];
      	WriteBElt[hd];
      	Map[ WriteTextNL, L ];
      	WriteEElt[hd];
      	WriteEElt["metadata"];
      );



ProcessCell[  Cell[cont_,hd_?isHeading,___] ] := 
    (
      	WriteBElt["omgroup","id",genID["omgroup"]];
      	WriteDCTitle[ cont,transH[hd]];
      	WriteEElt["omgroup"];
      );



$credat = {"Creator","Date"};

isCredat[str_String] := MemberQ[ $credat, str ];

ProcessCell[Cell[cnt_,"Creator",___ ]]:=
    (	
      WriteBElt[ "Creator","role","aut"];
      	WriteTextNL[cnt];
      	WriteEElt["Creator"];
      );

ProcessCell[Cell[cnt_,"Date",___ ]]:=
    (	
      WriteBElt[ "Date","action","update"];
      	WriteTextNL[cnt];
      	WriteEElt["Date"];
      );

ProcessCell[Cell[cnt_,tp_?isCredat,___]]:= 
    Print["*********** problem with author"];



$comquex = {"Comment","Question","Exercise","Hint","Warning","Note",
"RhetoricalQuestion","Problem"};

$comquexomdoc = {"comment","note","exercise","note","note","note","note",
      "note"};
AssignFunction[ comqtrans, $comquex, $comquexomdoc ]

isComquex[str_String] := MemberQ[ $comquex, str ];

ProcessCell[Cell[cnt_,tp_?isComquex,___]]:=With[{lowtp=comqtrans[tp]},
    	WriteBElt["omtext","id",genID["omtext"],"type",lowtp];
    	ProcessCell[cnt];
    	WriteEElt["omtext"]
    ]

ProcessCell[Cell[cnt_,tp_?isComquex,___]]:=With[{lowtp=comqtrans[tp]},
    	WriteBElt["omgroup","id",genID["omgroup"]];
    	ProcessCell[cnt,"type",lowtp];
    	WriteEElt["omgroup"]
    ]



ProcessCell[TextData[L_List,___],atts___] := 
(
  	WriteBElt[ "omtext", "id", genID["text"],atts ];
	WriteCMP[TextData[L]];
	WriteEElt[ "omtext" ]; 
);

ProcessCell[Cell[ cont_,"Text",___],atts___] := 
(
	WriteBElt[ "omtext", "id", genID["text"],atts ];
	WriteCMP[cont];
	WriteEElt[ "omtext" ];
);

ClearAll[ProcessText]
ProcessText[str_String] := 	WriteTextNLNone[str];
ProcessText[TextData[cnt_,___]] := Map[ ProcessText, cnt ];
ProcessText[StyleBox[str_String,___,FontSlant->"Italic"]] := 
(
	WriteBElt[ "with", "style", "emph" ];  
	WriteTextNL[str];
	WriteEElt[ "with" ]; 
);
ProcessText[StyleBox[str_String,___]] := WriteTextNL[str];

ProcessText[xxx_] := ProcessMath[xxx];	




$assertions = {"Theorem","Lemma","Proposition","Corollary"};

isAssertion[str_String] := MemberQ[ $assertions, str ];

ProcessCell[Cell[str_String,tp_?isAssertion,___]]:=
  With[{lowtp=ToLowerCase[tp]},
    	WriteBElt["assertion","id",genID[lowtp],"type",lowtp];
    	WriteCMP[str];
    	WriteEElt["assertion"]
    ]

ProcessCell[Cell[cnt_,tp_?isAssertion,___]]:=With[{lowtp=ToLowerCase[tp]},
    	WriteBElt["assertion","id",genID[lowtp],"type",lowtp];
    	WriteCMP[cnt];
    	WriteEElt["assertion"]
    ]



extractTags[tt___] :=
   With[ {tgs = CellTags /. {tt}},
    If[ Head[tgs] === List, {tgs, Length[tgs]}, {tgs, 1 } ] ]

ProcessCell[Cell[cont_,"Definition",tt___ ]]:=
  (
    Clear[sym,num];
    {sym,num} =extractTags[tt];
    If[ num \[NotEqual] 1,
      	Print[ "error:  Definition  ",cont ]; Return[] ];
    Print["++++ ",  sym ];
    	WriteElt["symbol","id",sym ];
    	WriteBElt["definition",  "id",  sym<>"-def", "for", sym ];
    	WriteCMP[cont];
        	WriteEElt["definition"]
    )



ProcessCell[ Cell[cnt_,"Proof",___]]:=
    (
      	proofstep = 0;
      	WriteBElt["proof","id",genID["proof"],"for","something"];
      );

ProcessCell[ Cell[str_String,"ProofStep",___]]:=
    (
      	WriteBElt["derive","id",genID["proofstep"]];
      	WriteCMP[str];
      	WriteEElt["derive"];
      );
ProcessCell[ Cell[cnt_,"ProofStep",___]]:=
    (
      	WriteBElt["derive","id",genID["proofstep"]];
      	WriteCMP[cnt];
      	WriteEElt["derive"];
      );

ProcessCell[ Cell[cnt_,"ProofEnd",___]]:=WriteEElt["proof"];



ProcessCell[Cell[cnt_,"Example",___]] := 
  (
    	WriteBElt["example","id",genID["example"], "for","who-knows"];
    	WriteCMP[cnt];
    	WriteEElt["example"];
    )



ProcessCell[Cell[BoxData[xx__]]] := 
    (
      	ProcessMath[Cell[BoxData[xx]]];
      );



ProcessCell[Cell[zzz___] ] :=Print[ Cell[zzz]];





processIO[inp_String] :=
  (
        WriteBElt["omtext","id",genID["text"]];
    	WriteBElt["CMP"];
    	ProcessMath[inp];
    	WriteEElt["CMP"];
    	WriteEElt["omtext"];
    
        WriteBElt["code","id",genID["code"]];
    	WriteBElt["data","format","mathematica"];
    	WriteCDATA[inp];
    	WriteEElt["data"];
    	WriteEElt["code"];
    )

processIO[Cell[BoxData[cont_],___]] :=
  (
    
        WriteBElt["omtext","id",genID["text"]];
    	WriteBElt["CMP"];
    	ProcessMath[Cell[BoxData[cont]]];
    	WriteEElt["CMP"];
    	WriteEElt["omtext"];
    
    	WriteBElt["code","id",genID["code"]];
    	WriteBElt["data","format","mathematica"];
    	WriteCDATA[ToString[cont,InputForm,CharacterEncoding\[Rule]None]];
    
    	If[$fulltrace,
      Print["<<<<  ",
        StringLength@ToString[cont,InputForm,CharacterEncoding\[Rule]None]]];
    
    	WriteEElt["data"];
    	WriteEElt["code"];
    )






$inputtypes={"InputExp","InputDef","InputDem"};
$inputtypes={"Input"};
isInput[str_String] := MemberQ[ $inputtypes, str ];
ProcessGroupHeader[  Cell[cont_,tp_?isInput ,tt___ ] ] := 
    (
      	WriteBElt["omgroup","id",genID["omgroup"]];
      (*	WriteBElt["metadata"];
        	WriteTextNL["<Title>mta i/o</Title>"];
        	WriteEElt["metadata"];  *)
      
      	ProcessCell[ Cell[cont,tp,tt ]];
      );
ProcessGroupHeader[  Cell[cont_,"Graphics" ,tt___ ] ] := 
    (
      	WriteBElt["omgroup","id",genID["omgroup"]];
      	WriteBElt["metadata"];
      	WriteTextNL["<Title>mta graphics</Title>"];
      	WriteEElt["metadata"];
      
      	ProcessCell[ Cell[cont,"Graphics" ]];
      );





ProcessCell[Cell[ inp_String, "InputDef",tt___]] := 
ProcessCell[ Cell[ BoxData[MakeBoxes[inp]], "InputDef",tt]];

ProcessCell[ Cell[ BoxData[cont_], "InputDef",tt___]] := 
(
If[ $traceinput,  Print["InputDef ",cont] ];
Clear[sym,num];

{sym,num} = extractTags[tt];

If[ num \[NotEqual] 1, Print["error:  InputDef  ", inp ]; Return[] ];

	WriteBElt["omgroup","id",genID["omgroup"]];

	WriteElt["symbol","id",sym];
	
	WriteBElt["definition","id",sym<>"-def","for",sym,"type","simple"];
	ProcessMath[Cell[BoxData[cont]]];
	WriteEElt["definition"];
	
	WriteBElt["code","id",genID["code"]];
	WriteBElt["data","format","mathematica"];
	WriteCDATA[ToString[cont,InputForm,CharacterEncoding\[Rule]None]];
	WriteEElt["data"];
	WriteEElt["code"];

	WriteEElt["omgroup"];
);



ProcessCell[Cell[ inp_String, "InputExp",tt___]] := 
	ProcessCell[ Cell[ BoxData[MakeBoxes[inp]], "InputExp",tt]];

ProcessCell[Cell[ BoxData[cont_], "InputExp",___]] := 
(
If[ $traceinput, Print["Input ",FullForm[ToExpression[ BoxData[cont]]]] ];

(*	WriteBElt["omgroup","id",genID["omgroup"]];
	WriteBElt["metadata"];
	WriteTextNL["<Title>mtain example</Title>"];
	WriteEElt["metadata"]; *)
	
	processIO[Cell[BoxData[cont]]];
	
(*	WriteEElt["omgroup"]; *)
);



ProcessCell[Cell[ inp_String, "Program",tt___]] := 
ProcessCell[Cell[BoxData[MakeBoxes[inp]], "Program", tt ] ];

ProcessCell[Cell[ BoxData[cont_], "Program",___]] := 
(
	WriteBElt["omgroup","id",genID["omgroup"]];
		
	WriteBElt["code","id",genID["code"]];
	WriteBElt["data","format","mathematica"];
	WriteCDATA[ToString[cont,InputForm,CharacterEncoding\[Rule]"ASCII"]];
	
	WriteEElt["data"];
	WriteEElt["code"];

	WriteEElt["omgroup"];
);





ProcessCell[Cell[BoxData[TagBox[___]],"Output",___]] := 
	Print[ "Graphics" ];

ProcessCell[Cell[ inp_String, "Output",tt___]] := 
	ProcessCell[Cell[ BoxData[MakeBoxes[inp]], "Output",tt]];

ProcessCell[Cell[ BoxData[cont_], "Output",___]] := 
(
	processIO[Cell[BoxData[cont]]];
);





pad4[x_] := StringJoin@@(ToString/@IntegerDigits[x,10,4]);
genGraphicsId[] := "graph" <> pad4[graphCnt++];
$graphtype = "gif";
$graphdir = $filename<>"-gifs";
ProcessCell[Cell[ cont_, "Graphics", tt___ ]] := 
(
If[ $tracegraph,  Print["Graphics "] ];

        graphdir = $filename<>"-gifs";
	grname = genGraphicsId[];
	grfile = graphdir<>"/"<>grname<>"."<>$graphtype;

	Print[  "++++ Graphics ", grname ];
(*	WriteBElt["omgroup","id",genID["omgroup"]];
	WriteBElt["metadata"];
	WriteTextNL["<Title>graphics</Title>"];
	WriteEElt["metadata"]; *)
	
WriteBElt["omtext","id",genID["text"]];
WriteBElt["CMP"];
WriteElt["omlet","function",grname,	"style", "embed", "type", "image", 
        "action","none"];
WriteEElt["CMP"];
WriteEElt["omtext"];

WriteBElt[ "private", "id", grname, "style", "image", "type", "image"];
WriteElt["data", "format", "image/"<>$graphtype, "href", grfile ];
WriteEElt["private"];
	
	Display[ grfile, Cell[ cont, "Graphics" ], "GIF", 
        ImageResolution\[Rule]144 ];
	
(*	WriteEElt["omgroup"]; *)
);





ClearAll[stringToBoxes]
stringToBoxes[str_String] := 
    ToBoxes[ToExpression[str,InputForm,Unevaluated]][[1,3]];

ClearAll[etoSML]
etoSML[str_String] := 
  XML`MathML`ExpressionToSymbolicMathML[  
    ToExpression[str,InputForm,Unevaluated],"Annotations"\[Rule]{},
    "Formats"\[Rule]{"ContentMathML"} ]

ClearAll[btoSML]
btoSML[ FormBox[bb_,TraditionalForm] ] := btoSML[RowBox[{bb}]];
btoSML[ee_] := 
    XML`MathML`BoxesToSymbolicMathML[ Unevaluated[ee],"Annotations"\[Rule]{},
      "Formats"\[Rule]{"ContentMathML"} ];



ClearAll[ProcessMath]
Attributes[ProcessMath]={HoldFirst};

ProcessMath[ cont_String,___]:=
    (
      	If[$tracemath,Print["*****  proc math  String"]];
      		If[$tracemath,Print[cont]];
      	      WriteTextNLNI[ procIntMathBoxes[stringToBoxes[cont]]];
      );

ProcessMath[Cell[BoxData[cntL_List],___]]:=
    (
      	If[$tracemath,Print["*****  proc math  Boxes"]];
      	If[$tracemath,Print[cntL]];
      	WriteTextNLNI[ procIntMathBoxes  /@ cntL ];
      );

ProcessMath[Cell[BoxData[cont__],___]]:=
    (
      	If[$tracemath,Print["*****  proc math  Boxes"]];
      	If[$tracemath,Print[cont]];
      	WriteTextNLNI[ procIntMathBoxes[ cont]];
      );

ClearAll[procIntMathString]
Attributes[procIntMathString]={HoldFirst};
procIntMathString[ee_] := 
  Module[ {sx},
    sx =  XML`MathML`ExpressionToSymbolicMathML[  
        	ToExpression[ee,InputForm,Unevaluated],
        	"Annotations"\[Rule]{},"OutputForms"\[Rule]{"Content"} ];
    If[$fulltrace,
      	Print["math string: ",ee];
      	Print[sx]];
    ExportString[sx //. omrules,"XML" ]  
    ]

ClearAll[procIntMathBoxes]
Attributes[procIntMathBoxes]={HoldFirst};
procIntMathBoxes[ee_] := 
  Module[ {sx},
    sx =  btoSML[ee];
    If[$fulltrace,
      	Print["math string: ",ee];
      	Print[sx]];
    ExportString[sx //. omrules,"XML",
      ConversionOptions\[Rule]{"ElementFormatting"\[Rule]Automatic} ]  
    ]





 ompre = {
      XMLElement[
          "apply",{},{ XMLElement["ci",{},{"CompoundExpression"}],xxx__,
            XMLElement["ci",{},{"Null"}]}] \[RuleDelayed] xxx,
      
      XMLElement[
          "apply",{},{ XMLElement["ci",{},{"MatrixForm"}],
            xxx__ }] \[RuleDelayed] xxx,
      
      XMLElement[
          "apply",{},{XMLElement["times",{},{}],top_,
            XMLElement[
              "apply",{},{XMLElement["power",{},{}],bot_,
                XMLElement["cn",{"type"\[Rule]"integer"},{"-1"}]}]}] :>
        XMLElement[
          "OMA",{},{XMLElement["OMS",{"cd"->"arith1","name"->"divide"},{}],
            top,bot}],
      
      XMLElement[
          "apply",{},{XMLElement["plus",{},{}],arg1_,
            XMLElement[
              "apply",{},{XMLElement["times",{},{}],
                XMLElement["cn",{"type"\[Rule]"integer"},{"-1"}],arg2_}]}]:>
        XMLElement[
          "OMA",{},{XMLElement["OMS",{"cd"->"arith1","name"->"minus"},{}],
            arg1, arg2 }],
      
      XMLElement[
          "apply",{},{XMLElement["times",{},{}],
            XMLElement["cn",{"type"\[Rule]"integer"},{"-1"}],
            arg_}] \[RuleDelayed]
        XMLElement[
          "OMA",{},{XMLElement[
              "OMS",{"cd"->"arith1","name"->"unary_minus"},{}],arg }],
      
      XMLElement["ci",{},{"SetDelayed"}] \[RuleDelayed] 
        XMLElement["OMS",{"cd"->"prog2","name"->"assignment"},{}],
      
      XMLElement["ci",{},{"Set"}] \[RuleDelayed] 
        XMLElement["OMS",{"cd"->"prog2","name"->"assignment"},{}],
      
       XMLElement["apply",{},{
            XMLElement["ci",{},{"Function"}],
            XMLElement["ci",{},{var_String}],body_ } ] \[RuleDelayed]
        XMLElement["OMBIND",{},{
            XMLElement["OMS",{"cd"->"fns1","name"->"lambda"},{}],
            
            XMLElement[
              "OMBVAR",{},{ XMLElement["OMV",{"name"\[Rule]var}, {} ] }],
            body }]
      };

omrgeneral = {
      XMLElement["math",att_, dat_ ] :> XMLElement["OMOBJ",{},dat ],
      XMLElement["apply",att_, dat_ ] :> XMLElement["OMA",att,dat], 
      XMLElement["selector",att_, dat_ ] :> 
        XMLElement["OMV",{"name"\[Rule]"Part"},{}] ,
      XMLElement["ci",att_, {"\[CenterEllipsis]"} ] :> 
        XMLElement[
          "OMS",{"cd"->"sequences", "name"\[Rule]"CenterEllipsis"}, {} ],
      XMLElement["ci",{}, {"Subscript"} ] :> 
        XMLElement["OMS",{"cd"->"scripts","name"\[Rule]"subscript"}, {} ],
      XMLElement["ci",att_, {xx_String} ] :> 
        XMLElement["OMV",{"name"\[Rule]xx}, {} ],
      XMLElement["cn",{"type"\[Rule]"integer"}, {xx_String} ] :> 
        XMLElement["OMI",{}, {xx} ],
      XMLElement["cn",{"type"\[Rule]"real"}, {xx_String} ] :> 
        XMLElement["OMF",{"dec"\[Rule]xx}, {} ],
      XMLElement["ms",{}, {xx_String} ] :> 
        XMLElement["OMV",{"name"\[Rule]xx}, {} ],
      
      XMLElement["msub",{}, {dat__} ] :> 
        XMLElement["OMS",{"cd"->"scripts","name"\[Rule]"subscript"}, {dat} ]
      }; 

omrlist = { 
      XMLElement["list",att_, dat_ ] :> 
        XMLElement["OMA",{},  
          Join[ {XMLElement["OMS",{"cd"->"list1","name"->"list"},{}]},dat]],
      XMLElement["union",{},{}] \[RuleDelayed] 
        XMLElement["OMS",{"cd"->"set1","name"->"union"},{}],
      XMLElement["intersection",{},{}] \[RuleDelayed] 
        XMLElement["OMS",{"cd"->"set1","name"->"intersection"},{}]
      };


omrspecial = {
      XMLElement["scalarproduct",att_, dat_ ] :> 
        XMLElement["OMV",{"name"->"Dot"},dat],
      XMLElement["infinity",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"nums1","name"->"infinity"},dat],
      
      XMLElement[
          "cn",{"type"->"rational"},{num_,XMLElement["sep",{},{}],den_} ] :> 
        XMLElement[
          "OMA",{},{XMLElement["OMS",{"cd"->"nums1","name"->"rational"},{}],
            XMLElement["OMI",{},{num}],XMLElement["OMI",{},{den}]}],
      
      
      
      XMLElement[
          "cn",{"type"->"complex-cartesian"},{xx_,XMLElement["sep",{},{}],
            yy_} ] :> XMLElement[
          "OMA",{},{XMLElement[
              "OMS",{"cd"->"complex1","name"->"complex_cartesian"},{}],
            XMLElement["OMI",{},{xx}],XMLElement["OMI",{},{yy}]}],
      
      
      XMLElement["imaginaryi",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"nums1","name"->"i"},dat],
      XMLElement["pi",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"nums1","name"->"pi"},dat],
      XMLElement["e",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"nums1","name"->"e"},dat],
      XMLElement["real",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"complex1","name"->"real"},dat],
      XMLElement["imaginary",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"complex1","name"->"imaginary"},dat],
      XMLElement["conjugate",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"complex1","name"->"conjugate"},dat],
      XMLElement["arg",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"complex1","name"->"argument"},dat],
      XMLElement["sinh",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"sinh"},dat],
      XMLElement["cosh",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"cosh"},dat],
      XMLElement["tan",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"tan"},dat],
      XMLElement["arctan",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"arctan"},dat],
      XMLElement["sin",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"sin"},dat],
      XMLElement["cos",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"transc1","name"->"cos"},dat],
      XMLElement["vectorproduct",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"linalg1","name"->"vectorproduct"},dat]
      };

omrrelation = {
      XMLElement["eq",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"eq"},dat],
      XMLElement["geq",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"geq"},dat],
      XMLElement["leq",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"leq"},dat],
      XMLElement["neq",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"neq"},dat],
      XMLElement["lt",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"lt"},dat],
      XMLElement["gt",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"relation1","name"->"gt"},dat]
      };

omrminmax = {
      XMLElement["min",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"minmax1","name"->"min"},{} ],
      XMLElement["max",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"minmax1","name"->"max"},{} ]
      };

omrlogic = {
      XMLElement["false",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"false"},{} ],
      XMLElement["true",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"true"},{} ],
      XMLElement["not",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"not"},{} ],
      XMLElement["implies",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"implies"},{} ],
      XMLElement["and",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"and"},{} ],
      XMLElement["xor",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"xor"},{} ],
      XMLElement["or",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"logic1","name"->"or"},{} ]
      };

omrround = {
      XMLElement["ceiling",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"round1","name"->"ceiling"},{} ],
      XMLElement["floor",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"round1","name"->"floor"},{} ]
      };

omrinteger = {
      XMLElement["rem",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"integer1","name"->"rem"},dat]
      };

omrarithmetic = {
      XMLElement["root",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"root"},dat],
      XMLElement["gcd",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"gcd"},dat],
      XMLElement["plus",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"plus"},dat],
      XMLElement["minus",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"minus"},dat],
      XMLElement["times",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"times"},dat],
      XMLElement["power",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"power"},dat],
      XMLElement["abs",att_, dat_ ] :> 
        XMLElement["OMS",{"cd"->"arith1","name"->"abs"},dat]
      };

omrcompound = 
    { { 
          XMLElement["product",{} ,{} ],
          XMLElement["bvar",{}, {bv_} ],
          XMLElement["lowlimit",{}, {lol_} ],
          XMLElement["uplimit",{}, {upl_} ],
           xmlelm_ }  :> 
        {   XMLElement["OMS",{"cd"->"arith1","name"->"prod"},{}],
             
          XMLElement[
            "OMA",{},{XMLElement[
                "OMS",{"cd"->"interval1","name"->"integer_interval"},{}],lol,
              upl }],
             XMLElement["OMBIND",{},{
              XMLElement["OMS",{"cd"->"fns1","name"->"lambda"},{}],
              XMLElement["OMBVAR",{},{bv}],
              xmlelm } ] },
      { 
          XMLElement["sum",{} ,{} ],
          XMLElement["bvar",{}, {bv_} ],
          XMLElement["lowlimit",{}, {lol_} ],
          XMLElement["uplimit",{}, {upl_} ],
           xmlelm_ }  :> 
        {   XMLElement["OMS",{"cd"->"arith1","name"->"sum"},{}],
             
          XMLElement[
            "OMA",{},{XMLElement[
                "OMS",{"cd"->"interval1","name"->"integer_interval"},{}],lol, 
              upl } ],
             XMLElement["OMBIND",{},{
              XMLElement["OMS",{"cd"->"fns1","name"->"lambda"},{}],
              XMLElement["OMBVAR",{},{bv}],
              xmlelm } ]  } };

omrsequ = {
      XMLElement["OMV",{"name"->"EllipsisInfix"},{} ] :> 
        XMLElement["OMS",{"cd"->"sequences","name"->"ellipsis_infix"},{}],
      XMLElement["OMV",{"name"->"EllipsisInfixPlus"},{} ] :> 
        XMLElement[
          "OMS",{"cd"->"sequences","name"->"ellipsis_infix_plus"},{}],
      XMLElement["OMV",{"name"->"EllipsisInfixTimes"},{} ] :> 
        XMLElement[
          "OMS",{"cd"->"sequences","name"->"ellipsis_infix_times"},{}]
      };

ommat= {
      XMLElement["list",{}, 
          XX:{XMLElement["list",{},{__}]..}] \[RuleDelayed] 
        XMLElement["apply",{},{ 
            XMLElement["OMS",{"cd"->"linalg2", "name"\[Rule]"matrix"},{}],
            
            Sequence@@(XMLElement[
                      "apply",{},{XMLElement[
                          "OMS",{"cd"->"linalg2", 
                            "name"\[Rule]"matrixrow"},{}],
                        Sequence@@(#[[3]])}]& /@ XX)} ]};

omrules = 
    Dispatch[Join[ ompre, omrgeneral, omrspecial, ommat, omrlist,omrminmax,
        omrrelation, omrlogic, omrarithmetic, omrround, omrinteger, 
        omrcompound , omrsequ ]];