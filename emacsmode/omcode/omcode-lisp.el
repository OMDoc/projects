;;;;;;;;;;;;;;;;;;;;;;;;
;;; A first attempt for the encoding 
;;; of LISP source code into omdoc.
;;; (MP)
;;;;;;;;;;;;;;;;;;;;;;;;

(require 'lisp-mode)

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Output-Strings
;;;;;;;;;;;;;;;;;;;;;;;;

(defvar omcode-comment ";;;om;;;")		

(defvar omcode-dtd "~/ILO/dtd/omdoc.dtd")

(defvar omcode-start "<code")		
(defvar omcode-end "</code>")		

(defun omcode-open (id require theo type)
    (concat omcode-start 
	    " requires='" (prin1-to-string require) "'"
	    " Ident='" (prin1-to-string id) "'"
	    " theory='" theo "'"
	    " type='" (prin1-to-string type) "'"
	    " pto='Omega'"
	    " pto-version='3.0'"
	    " format='LISP'" 
	    "><data>[CDATA["))

(defun omcode-close ()
  (concat "\n"omcode-comment "]]</data>" omcode-end "\n"))

(defun omcode-prefix ()
  (let ((bname (buffer-name (current-buffer))))
    (list "<?xml version=\"1.0\"?>"
	  (concat "<!DOCTYPE omdoc SYSTEM '" omcode-dtd "' []>")
	  "<!--  This file is generated by the OMEGA system, do not edit  -->"
	  (concat "<omdoc Ident='" bname "'>")
	  "<metadata>"
	  (concat "<dc:Title>" (substring bname 0 
					  (or (search "." bname)
					      (length bname)))
		  "</dc:Title>")
	  "<dc:Creator role='aut'>The OMEGA Group</dc:Creator>"
	  (concat "<dc:Date>" (current-time-string) "</dc:Date>")
	  "</metadata>")))		

(defvar omcode-postfix "</omdoc>")

;(defvar omcode-funs "(defun\\|(infer~def\\|(tac~def") 

;;;;;;;;;;;;;;;;;;;;;;;;
;;; commands
;;;;;;;;;;;;;;;;;;;;;;;;

(defun omcode-insert-header ()
  "Inserts the xml and omdoc head (incl. metadata) for omcode-decls."
  (interactive)
  (goto-char(point-min))
  (dolist (line (omcode-prefix))
    (insert (concat omcode-comment line "\n")))
  (goto-char(point-max))
    (insert (concat "\n" omcode-comment omcode-postfix "\n")))

(defun omcode-update ()
  "Inserts or updates a omcode-declaration around the current LISP function."
  (interactive)
  (goto-char (point))
  (let* ((begin (lisp-defun-begin))
	 (nextbegin (progn (beginning-of-defun)(lisp-defun-begin)))
	 (end (progn (goto-char begin) (lisp-defun-end)))
	 (nextend (progn (end-of-defun)(end-of-defun) (lisp-defun-end)))
	 (nextend (if (= end nextend) (point-max) nextend)) 
	 (list (read (set-marker (make-marker) begin)))
	 (type (first list))
	 (name (second list))
	 (bname (buffer-name (current-buffer)))
	 (theo (substring bname 0 
			  (or (search "-" bname)
			      (search "." bname)
			      (length bname))))
	 (uses (remove-duplicates (omcode-collect-functions (cdddr list))))
	 (pre  (omcode-open name uses theo type))
	 (post (omcode-close)))
    (print (list begin nextbegin end nextend))
    (goto-char end)
    (when (not (search-forward omcode-end nextend t))
      (goto-char end)(insert post))
    (goto-char begin)
    (if (search-backward omcode-start nextbegin t)
	(progn (kill-line)
	       (insert pre))
      (progn (goto-char begin)
	     (insert (concat omcode-comment pre "\n"))))
    (goto-char (search-forward omcode-end))
  nextend))

(defun omcode-buffer ()
  "Calls omcode-update for every LISP function."
  (interactive)
  (goto-char 1)
  (do ((current 1 (omcode-update)))
      ((= current (point-max)))
    (end-of-defun)))

;;;;;;;;;;;;;;;;;;;;;;;;
;;; functions
;;;;;;;;;;;;;;;;;;;;;;;;

(defun omcode-collect-functions (obj)
  (cond  ((null obj) nil)
	 ((omcode-function-name-p obj)  (list obj))
	 ((consp obj) (append (omcode-collect-functions (car obj))
			      (omcode-collect-functions (cdr obj))))))

(defun omcode-function-name-p (name)
  (and (atom name)
       (let ((test (search "=" (prin1-to-string name))))
	    (and test
		 (plusp test)))))

;;;;;;;;;;;;;;;;;;;;;;;;
;;; testing
;;;;;;;;;;;;;;;;;;;;;;;;

(defun test ()
  (interactive)
  (print nil))
