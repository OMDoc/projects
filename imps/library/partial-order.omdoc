<?xml version="1.0"?>
<!DOCTYPE omdoc PUBLIC "-//OMDoc//DTD OMDoc V1.2//EN" "../dtd/omdoc-basic.dtd" [<!ENTITY % om.prefixed "INCLUDE">]>

<omdoc xml:id="PARTIAL-ORDER-omdoc"
       xmlns="http://omdoc.org/ns"
       xmlns:dc='http://purl.org/dc/elements/1.1/'
       xmlns:om="http://www.openmath.org/OpenMath">

<metadata>
 <dc:title>The theory PARTIAL-ORDER in IMPS</dc:title>
 <dc:source>IMPS: An Interactive Mathematical Proof System
 </dc:source>
 <dc:creator role="aut">W.M. Farmer</dc:creator>
 <dc:creator role="aut">J.D. Guttman</dc:creator>
 <dc:creator role="aut">F.J. Thayer</dc:creator>
 <dc:contributor role="trl">Yan Li</dc:contributor>
 <dc:contributor role="edt">Marc Bender</dc:contributor>
 <dc:date action="created">2002-01-01</dc:date>
 <dc:date action="updated">2005-01-01</dc:date>
</metadata>


<theory xml:id="partial-order">

<omgroup xml:id="partial-order-component-theories" type="sequence">
<metadata>
 <dc:title>Component theories</dc:title>
</metadata>


<imports xml:id="h-o-real-arithmetic.import"  from="h-o-real-arithmetic"/>
<omtext xml:id="h-o-real-arithmetic.import-display">
 <CMP>
 "h-o-real-arithmetic" - component theory of "partial-order".
 </CMP>
</omtext>

</omgroup>




<omgroup xml:id="language-for-partial-order" type="sequence">
<metadata>
 <dc:title> The symbols in "language-for-partial-order" </dc:title>
</metadata>

<omtext xml:id="language-for-partial-order-intro">
 <CMP> "language-for-partial-order" - language of the theory "partial-order". </CMP>
</omtext>

<symbol xml:id="uu" kind="sort">
 <CMP> "uu" - primitive sort of the theory "partial-order". </CMP>
</symbol>

<type system="imps-sorts" for="uu">
 <CMP> The enclosing sort of "uu" is "uu". </CMP>
 <om:OMOBJ>
  <om:OMS cd="partial-order" name="uu"/>
 </om:OMOBJ>
</type>


<symbol xml:id="prec" kind="object">
 <CMP> "prec" - primitive constant of the theory "partial-order". </CMP>
</symbol>

<type system="imps-sorts" for="prec">
 <CMP> The sort of "prec" is "[uu,uu,prop]". </CMP>
 <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="funsort"/>
     <om:OMS cd="partial-order" name="uu"/>
     <om:OMS cd="partial-order" name="uu"/>
     <om:OMS cd="the-kernel-theory" name="prop"/>
   </om:OMA>
 </om:OMOBJ>
</type>


</omgroup>


<omgroup xml:id="axioms-of-partial-order" type="sequence">
<metadata>
 <dc:title> Axioms </dc:title>
</metadata>

<omtext xml:id="partial-order-axioms-intro">
 <CMP> The axioms of the theory "partial-order" (which are not from its component theories). </CMP>
</omtext>


<axiom xml:id="prec-anti-symmetry">
<CMP>
 Axiom name: "prec-anti-symmetry". <with style="linebreak"/>

 Formula (string): "forall(a,b:uu,a prec b and b prec a implies a=b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b))
 (implies (and (apply-operator prec a b) (apply-operator prec b a)) (= a b)))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="b"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</axiom>


<axiom xml:id="prec-reflexivity">
<CMP>
 Axiom name: "prec-reflexivity". <with style="linebreak"/>

 Formula (string): "forall(a:uu,a prec a)". <with style="linebreak"/>

 Formula (s-expression): "(forall ((uu a)) (apply-operator prec a a))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="prec"/>
     <om:OMV name="a"/>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</axiom>


<axiom xml:id="prec-transitivity">
<CMP>
 Axiom name: "prec-transitivity". <with style="linebreak"/>

 Formula (string): "forall(a,b,c:uu,a prec b and b prec c implies a prec c)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b c))
 (implies (and (apply-operator prec a b) (apply-operator prec b c))
  (apply-operator prec a c)))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="c"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="b"/>
       <om:OMV name="c"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMV name="a"/>
      <om:OMV name="c"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</axiom>

</omgroup>


<omgroup xml:id="events-of-partial-order" type="sequence">
<metadata>
 <dc:title>Events</dc:title>
</metadata>

<omtext xml:id="partial-order-events-intro">
 <CMP>
  The events of the theory "partial-order" in load order.
 </CMP>
</omtext>


<assertion xml:id="prec-transitivity"  type="theorem">
<CMP>
 Theorem name: "prec-transitivity". <with style="linebreak"/>

 Formula (string): "forall(a,b,c:uu,a prec b and b prec c implies a prec c)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b c))
 (implies (and (apply-operator prec a b) (apply-operator prec b c))
  (apply-operator prec a c)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="c"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="b"/>
       <om:OMV name="c"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMV name="a"/>
      <om:OMV name="c"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="prec-reflexivity"  type="theorem">
<CMP>
 Theorem name: "prec-reflexivity". <with style="linebreak"/>

 Formula (string): "forall(a:uu,a prec a)". <with style="linebreak"/>

 Formula (s-expression): "(forall ((uu a)) (apply-operator prec a a))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="prec"/>
     <om:OMV name="a"/>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="prec-anti-symmetry"  type="theorem">
<CMP>
 Theorem name: "prec-anti-symmetry". <with style="linebreak"/>

 Formula (string): "forall(a,b:uu,a prec b and b prec a implies a=b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b))
 (implies (and (apply-operator prec a b) (apply-operator prec b a)) (= a b)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="b"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="rev%prec" kind="object">
<CMP> "rev%prec" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="rev%prec-def"  for="rev%prec"  type="simple">
<CMP>
 Symbol name: "rev%prec". <with style="linebreak"/>

 String defining expression: "lambda(a,b:uu,b prec a)". <with style="linebreak"/>

 Defining s-expression: "(lambda ((uu a b)) (apply-operator prec b a))". <with style="linebreak"/>

 Usage list: "rewrite". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="prec"/>
     <om:OMV name="b"/>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): 
"forall(a,c:uu,
  forsome(b:uu,b prec a and c prec b) implies c prec a)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a c))
 (implies
  (forsome ((uu b)) (and (apply-operator prec b a) (apply-operator prec c b)))
  (apply-operator prec c a)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="c"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="partial-order" name="uu"/>
        </om:OMATP>
        <om:OMV name="b"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec"/>
        <om:OMV name="b"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec"/>
        <om:OMV name="c"/>
        <om:OMV name="b"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMV name="c"/>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): "forall(a,b:uu,b prec a and a prec b implies a=b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b))
 (implies (and (apply-operator prec b a) (apply-operator prec a b)) (= a b)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="b"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): "prec=lambda(a,b:uu,a prec b)". <with style="linebreak"/>

 Formula (s-expression): "(= prec (lambda ((uu a b)) (apply-operator prec a b)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="="/>
    <om:OMS cd="partial-order" name="prec"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="a"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="b"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMBIND>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="prec%majorizes" kind="object">
<CMP> "prec%majorizes" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%majorizes-def"  for="prec%majorizes"  type="simple">
<CMP>
 Symbol name: "prec%majorizes". <with style="linebreak"/>

 String defining expression: "lambda(y:uu,s:sets[uu],forall(x:uu,x in s implies x prec y))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((uu y) ((uu unit%sort) s))
 (forall ((uu x)) (implies (i-in x s) (apply-operator prec x y))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>


<symbol xml:id="prec%sup" kind="object">
<CMP> "prec%sup" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%sup-def"  for="prec%sup"  type="simple">
<CMP>
 Symbol name: "prec%sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[uu],
  iota(y:uu,
    y prec%majorizes s
     and 
    forall(z:uu,z prec%majorizes s implies y prec z)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((uu unit%sort) s))
 (iota ((uu y))
  (and (apply-operator prec%majorizes y s)
   (forall ((uu z))
    (implies (apply-operator prec%majorizes z s) (apply-operator prec y z))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%majorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="partial-order" name="uu"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec%majorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec"/>
         <om:OMV name="y"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="iota-free-characterization-of-prec%sup"  type="theorem">
<CMP>
 Theorem name: "iota-free-characterization-of-prec%sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[uu],y:uu,
  prec%sup(s)=y
   iff 
  (y prec%majorizes s
   and 
  forall(y_1:uu,y_1 prec%majorizes s implies y prec y_1)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s) (uu y))
 (iff (= (apply-operator prec%sup s) y)
  (and (apply-operator prec%majorizes y s)
   (forall ((uu y_1))
    (implies (apply-operator prec%majorizes y_1 s)
     (apply-operator prec y y_1))))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="y"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%majorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="partial-order" name="uu"/>
         </om:OMATP>
         <om:OMV name="y_1"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec%majorizes"/>
         <om:OMV name="y_1"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec"/>
         <om:OMV name="y"/>
         <om:OMV name="y_1"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="iota-free-characterization-of-prec%sup-existence"  type="theorem">
<CMP>
 Theorem name: "iota-free-characterization-of-prec%sup-existence". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[uu],y:uu,
  #(prec%sup(s))
   iff 
  forsome(y:uu,
    y prec%majorizes s
     and 
    forall(y_1:uu,y_1 prec%majorizes s implies y prec y_1)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s) (uu y))
 (iff (is-defined (apply-operator prec%sup s))
  (forsome ((uu y))
   (and (apply-operator prec%majorizes y s)
    (forall ((uu y_1))
     (implies (apply-operator prec%majorizes y_1 s)
      (apply-operator prec y y_1)))))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="partial-order" name="uu"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%majorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="partial-order" name="uu"/>
          </om:OMATP>
          <om:OMV name="y_1"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="prec%majorizes"/>
          <om:OMV name="y_1"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="partial-order" name="prec"/>
          <om:OMV name="y"/>
          <om:OMV name="y_1"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="prec%majorizes-property-of-prec%sup"  type="theorem">
<CMP>
 Theorem name: "prec%majorizes-property-of-prec%sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[uu],
  #(prec%sup(s)) implies prec%sup(s) prec%majorizes s)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s))
 (implies (is-defined (apply-operator prec%sup s))
  (apply-operator prec%majorizes (apply-operator prec%sup s) s)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec%majorizes"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="lub-property-of-prec%sup"  type="theorem">
<CMP>
 Theorem name: "lub-property-of-prec%sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[uu],y:uu,
  y prec%majorizes s and #(prec%sup(s))
   implies 
  prec%sup(s) prec y)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s) (uu y))
 (implies
  (and (apply-operator prec%majorizes y s)
   (is-defined (apply-operator prec%sup s)))
  (apply-operator prec (apply-operator prec%sup s) y)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%majorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="y"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="monotonicity-of-prec%sup"  type="theorem">
<CMP>
 Theorem name: "monotonicity-of-prec%sup". <with style="linebreak"/>

 Formula (string): 
"forall(s,t:sets[uu],
  s subseteq t and #(prec%sup(t)) and #(prec%sup(s))
   implies 
  prec%sup(s) prec prec%sup(t))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s t))
 (implies
  (and (i-subseteq s t) (is-defined (apply-operator prec%sup t))
   (is-defined (apply-operator prec%sup s)))
  (apply-operator prec (apply-operator prec%sup s)
   (apply-operator prec%sup t))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="t"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
       <om:OMV name="s"/>
       <om:OMV name="t"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%sup"/>
        <om:OMV name="t"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="t"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="prec%increasing" kind="object">
<CMP> "prec%increasing" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%increasing-def"  for="prec%increasing"  type="simple">
<CMP>
 Symbol name: "prec%increasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,uu],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies s(n) prec s(p)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz uu) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator prec (apply-operator s n) (apply-operator s p)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec"/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-prec%minorizes_partial-order"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-prec%minorizes_partial-order". <with style="linebreak"/>

 Formula (string): 
"#(lambda(y:uu,s:sets[uu],
    forall(x:uu,x in s implies x rev%prec y)),[uu,sets[uu],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda ((uu y) ((uu unit%sort) s))
  (forall ((uu x)) (implies (i-in x s) (apply-operator rev%prec x y))))
 (uu (uu unit%sort) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="partial-order" name="uu"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="partial-order" name="uu"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="partial-order" name="rev%prec"/>
        <om:OMV name="x"/>
        <om:OMV name="y"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMS cd="partial-order" name="uu"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="partial-order" name="uu"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="prec%minorizes" kind="object">
<CMP> "prec%minorizes" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%minorizes-def"  for="prec%minorizes"  type="simple">
<CMP>
 Symbol name: "prec%minorizes". <with style="linebreak"/>

 String defining expression: 
"lambda(y:uu,s:sets[uu],
  forall(x:uu,x in s implies x rev%prec y))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((uu y) ((uu unit%sort) s))
 (forall ((uu x)) (implies (i-in x s) (apply-operator rev%prec x y))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-prec%inf_partial-order"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-prec%inf_partial-order". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:sets[uu],
    iota(y:uu,
      y prec%minorizes s
       and 
      forall(z:uu,
        z prec%minorizes s implies y rev%prec z))),[sets[uu],uu])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((uu unit%sort) s))
  (iota ((uu y))
   (and (apply-operator prec%minorizes y s)
    (forall ((uu z))
     (implies (apply-operator prec%minorizes z s)
      (apply-operator rev%prec y z))))))
 ((uu unit%sort) uu))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="partial-order" name="uu"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="iota"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="partial-order" name="uu"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%minorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="partial-order" name="uu"/>
          </om:OMATP>
          <om:OMV name="z"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="prec%minorizes"/>
          <om:OMV name="z"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="partial-order" name="rev%prec"/>
          <om:OMV name="y"/>
          <om:OMV name="z"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="partial-order" name="uu"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="partial-order" name="uu"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="prec%inf" kind="object">
<CMP> "prec%inf" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%inf-def"  for="prec%inf"  type="simple">
<CMP>
 Symbol name: "prec%inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[uu],
  iota(y:uu,
    y prec%minorizes s
     and 
    forall(z:uu,z prec%minorizes s implies y rev%prec z)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((uu unit%sort) s))
 (iota ((uu y))
  (and (apply-operator prec%minorizes y s)
   (forall ((uu z))
    (implies (apply-operator prec%minorizes z s)
     (apply-operator rev%prec y z))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%minorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="partial-order" name="uu"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec%minorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="partial-order" name="rev%prec"/>
         <om:OMV name="y"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-rev%prec%increasing_partial-order"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-rev%prec%increasing_partial-order". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,uu],
    forall(n,p:zz,
      n&lt;=p and #(s(n)) and #(s(p))
       implies 
      s(n) rev%prec s(p))),[[zz,uu],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz uu) s))
  (forall ((zz n p))
   (implies
    (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
     (is-defined (apply-operator s p)))
    (apply-operator rev%prec (apply-operator s n) (apply-operator s p)))))
 ((zz uu) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="partial-order" name="uu"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="p"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="partial-order" name="rev%prec"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        <om:OMS cd="partial-order" name="uu"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="rev%prec%increasing" kind="object">
<CMP> "rev%prec%increasing" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="rev%prec%increasing-def"  for="rev%prec%increasing"  type="simple">
<CMP>
 Symbol name: "rev%prec%increasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,uu],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies 
    s(n) rev%prec s(p)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz uu) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator rev%prec (apply-operator s n) (apply-operator s p)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>


<symbol xml:id="prec%lim%inf" kind="object">
<CMP> "prec%lim%inf" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%lim%inf-def"  for="prec%lim%inf"  type="simple">
<CMP>
 Symbol name: "prec%lim%inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,uu],
  prec%sup(ran{lambda(n:zz,
                 prec%inf(ran{lambda(m:zz,
                                if(n&lt;=m, s(m), ?uu))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz uu) s))
 (apply-operator prec%sup
  (m-range
   (lambda ((zz n))
    (apply-operator prec%inf
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined uu)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="prec%sup"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="partial-order" name="prec%inf"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="partial-order" name="uu"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-prec%lim%sup_partial-order"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-prec%lim%sup_partial-order". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,uu],
    prec%inf(ran{lambda(n:zz,
                   prec%sup(ran{lambda(m:zz,
                                  if(n&lt;=m, s(m), ?uu))}))})),[[zz,uu],uu])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz uu) s))
  (apply-operator prec%inf
   (m-range
    (lambda ((zz n))
     (apply-operator prec%sup
      (m-range
       (lambda ((zz m))
        (if (apply-operator &lt;= n m) (apply-operator s m) (undefined uu)))))))))
 ((zz uu) uu))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="partial-order" name="uu"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="partial-order" name="prec%inf"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="partial-order" name="prec%sup"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-range"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="m"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="s"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="undefined"/>
             <om:OMS cd="partial-order" name="uu"/>
             </om:OMA>

            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
       <om:OMS cd="partial-order" name="uu"/>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="prec%lim%sup" kind="object">
<CMP> "prec%lim%sup" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="prec%lim%sup-def"  for="prec%lim%sup"  type="simple">
<CMP>
 Symbol name: "prec%lim%sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,uu],
  prec%inf(ran{lambda(n:zz,
                 prec%sup(ran{lambda(m:zz,
                                if(n&lt;=m, s(m), ?uu))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz uu) s))
 (apply-operator prec%inf
  (m-range
   (lambda ((zz n))
    (apply-operator prec%sup
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined uu)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="prec%inf"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="partial-order" name="prec%sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="partial-order" name="uu"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="minorizes-property-of-prec%sup"  type="theorem">
<CMP>
 Theorem name: "minorizes-property-of-prec%sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[uu],y:uu,
  forsome(z:uu,z in s and y prec z) and #(prec%sup(s))
   implies 
  y prec prec%sup(s))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((uu unit%sort) s) (uu y))
 (implies
  (and (forsome ((uu z)) (and (i-in z s) (apply-operator prec y z)))
   (is-defined (apply-operator prec%sup s)))
  (apply-operator prec y (apply-operator prec%sup s))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="partial-order" name="uu"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="partial-order" name="uu"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="i-in"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="partial-order" name="prec"/>
         <om:OMV name="y"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="prec%sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="prec"/>
      <om:OMV name="y"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="decreasing-property-of-sup-tail"  type="theorem">
<CMP>
 Theorem name: "decreasing-property-of-sup-tail". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,uu],
  rev%prec%increasing(lambda(m:zz,
                        prec%sup(ran{lambda(k:zz,
                                       if(m&lt;=k, s(k), ?uu))}))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz uu) s))
 (apply-operator rev%prec%increasing
  (lambda ((zz m))
   (apply-operator prec%sup
    (m-range
     (lambda ((zz k))
      (if (apply-operator &lt;= m k) (apply-operator s k) (undefined uu))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="partial-order" name="uu"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="rev%prec%increasing"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="lambda"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="m"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="partial-order" name="prec%sup"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-range"/>
        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="lambda"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="k"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="if"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMV name="m"/>
           <om:OMV name="k"/>
          </om:OMA>
          <om:OMA>
           <om:OMV name="s"/>
           <om:OMV name="k"/>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="undefined"/>
           <om:OMS cd="partial-order" name="uu"/>
           </om:OMA>

          </om:OMA>
         </om:OMBIND>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): 
"forall(a,b,c:uu,
  a rev%prec b and b rev%prec c implies a rev%prec c)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b c))
 (implies (and (apply-operator rev%prec a b) (apply-operator rev%prec b c))
  (apply-operator rev%prec a c)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="c"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMV name="b"/>
       <om:OMV name="c"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="rev%prec"/>
      <om:OMV name="a"/>
      <om:OMV name="c"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): "prec=lambda(a,b:uu,b rev%prec a)". <with style="linebreak"/>

 Formula (s-expression): "(= prec (lambda ((uu a b)) (apply-operator rev%prec b a)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="="/>
    <om:OMS cd="partial-order" name="prec"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="a"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="partial-order" name="uu"/>
       </om:OMATP>
       <om:OMV name="b"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="partial-order" name="rev%prec"/>
      <om:OMV name="b"/>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMBIND>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): "forall(a:uu,a rev%prec a)". <with style="linebreak"/>

 Formula (s-expression): "(forall ((uu a)) (apply-operator rev%prec a a))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="rev%prec"/>
     <om:OMV name="a"/>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nil"  type="theorem">
<CMP>
 Theorem name: "nil". <with style="linebreak"/>

 Formula (string): "forall(a,b:uu,a rev%prec b and b rev%prec a implies a=b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((uu a b))
 (implies (and (apply-operator rev%prec a b) (apply-operator rev%prec b a))
  (= a b)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="partial-order" name="uu"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="partial-order" name="rev%prec"/>
       <om:OMV name="b"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sort-definedness-formula-for-majorizes_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-majorizes_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): "#(lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies x&lt;=y)),[rr,sets[rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda ((rr y) ((rr unit%sort) s))
  (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= x y))))
 (rr (rr unit%sort) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="x"/>
        <om:OMV name="y"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="majorizes" kind="object">
<CMP> "majorizes" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="majorizes-def"  for="majorizes"  type="simple">
<CMP>
 Symbol name: "majorizes". <with style="linebreak"/>

 String defining expression: "lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies x&lt;=y))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr y) ((rr unit%sort) s))
 (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= x y))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-sup_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-sup_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:sets[rr],
    iota(y:rr,
      y majorizes s
       and 
      forall(z:rr,z majorizes s implies y&lt;=z))),[sets[rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((rr unit%sort) s))
  (iota ((rr y))
   (and (apply-operator majorizes y s)
    (forall ((rr z))
     (implies (apply-operator majorizes z s) (apply-operator &lt;= y z))))))
 ((rr unit%sort) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="iota"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="majorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="z"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="majorizes"/>
          <om:OMV name="z"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="y"/>
          <om:OMV name="z"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="sup" kind="object">
<CMP> "sup" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="sup-def"  for="sup"  type="simple">
<CMP>
 Symbol name: "sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  iota(y:rr,
    y majorizes s
     and 
    forall(z:rr,z majorizes s implies y&lt;=z)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (iota ((rr y))
  (and (apply-operator majorizes y s)
   (forall ((rr z))
    (implies (apply-operator majorizes z s) (apply-operator &lt;= y z))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="majorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="majorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="y"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-nondecreasing_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-nondecreasing_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    forall(n,p:zz,
      n&lt;=p and #(s(n)) and #(s(p)) implies s(n)&lt;=s(p))),[[zz,rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (forall ((zz n p))
   (implies
    (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
     (is-defined (apply-operator s p)))
    (apply-operator &lt;= (apply-operator s n) (apply-operator s p)))))
 ((zz rr) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="p"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="nondecreasing" kind="object">
<CMP> "nondecreasing" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="nondecreasing-def"  for="nondecreasing"  type="simple">
<CMP>
 Symbol name: "nondecreasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies s(n)&lt;=s(p)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator &lt;= (apply-operator s n) (apply-operator s p)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-minorizes_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-minorizes_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): "#(lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies y&lt;=x)),[rr,sets[rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda ((rr y) ((rr unit%sort) s))
  (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= y x))))
 (rr (rr unit%sort) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="y"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="minorizes" kind="object">
<CMP> "minorizes" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="minorizes-def"  for="minorizes"  type="simple">
<CMP>
 Symbol name: "minorizes". <with style="linebreak"/>

 String defining expression: "lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies y&lt;=x))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr y) ((rr unit%sort) s))
 (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= y x))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="y"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-inf_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-inf_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:sets[rr],
    iota(y:rr,
      y minorizes s
       and 
      forall(z:rr,z minorizes s implies z&lt;=y))),[sets[rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((rr unit%sort) s))
  (iota ((rr y))
   (and (apply-operator minorizes y s)
    (forall ((rr z))
     (implies (apply-operator minorizes z s) (apply-operator &lt;= z y))))))
 ((rr unit%sort) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="iota"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="minorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="z"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="minorizes"/>
          <om:OMV name="z"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="z"/>
          <om:OMV name="y"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="inf" kind="object">
<CMP> "inf" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="inf-def"  for="inf"  type="simple">
<CMP>
 Symbol name: "inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  iota(y:rr,
    y minorizes s
     and 
    forall(z:rr,z minorizes s implies z&lt;=y)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (iota ((rr y))
  (and (apply-operator minorizes y s)
   (forall ((rr z))
    (implies (apply-operator minorizes z s) (apply-operator &lt;= z y))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="minorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="minorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="z"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-nonincreasing_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-nonincreasing_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    forall(n,p:zz,
      n&lt;=p and #(s(n)) and #(s(p)) implies s(p)&lt;=s(n))),[[zz,rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (forall ((zz n p))
   (implies
    (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
     (is-defined (apply-operator s p)))
    (apply-operator &lt;= (apply-operator s p) (apply-operator s n)))))
 ((zz rr) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="p"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="nonincreasing" kind="object">
<CMP> "nonincreasing" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="nonincreasing-def"  for="nonincreasing"  type="simple">
<CMP>
 Symbol name: "nonincreasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies s(p)&lt;=s(n)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator &lt;= (apply-operator s p) (apply-operator s n)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-lim%inf_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-lim%inf_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    sup(ran{lambda(n:zz,
              inf(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))})),[[zz,rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (apply-operator sup
   (m-range
    (lambda ((zz n))
     (apply-operator inf
      (m-range
       (lambda ((zz m))
        (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))
 ((zz rr) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="partial-order" name="sup"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="partial-order" name="inf"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-range"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="m"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="s"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="undefined"/>
             <om:OMS cd="h-o-real-arithmetic" name="rr"/>
             </om:OMA>

            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="lim%inf" kind="object">
<CMP> "lim%inf" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="lim%inf-def"  for="lim%inf"  type="simple">
<CMP>
 Symbol name: "lim%inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  sup(ran{lambda(n:zz,
            inf(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (apply-operator sup
  (m-range
   (lambda ((zz n))
    (apply-operator inf
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="sup"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="partial-order" name="inf"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="h-o-real-arithmetic" name="rr"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-lim%sup_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-lim%sup_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    inf(ran{lambda(n:zz,
              sup(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))})),[[zz,rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (apply-operator inf
   (m-range
    (lambda ((zz n))
     (apply-operator sup
      (m-range
       (lambda ((zz m))
        (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))
 ((zz rr) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="partial-order" name="inf"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="partial-order" name="sup"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-range"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="m"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="s"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="undefined"/>
             <om:OMS cd="h-o-real-arithmetic" name="rr"/>
             </om:OMA>

            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="lim%sup" kind="object">
<CMP> "lim%sup" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="lim%sup-def"  for="lim%sup"  type="simple">
<CMP>
 Symbol name: "lim%sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  inf(ran{lambda(n:zz,
            sup(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (apply-operator inf
  (m-range
   (lambda ((zz n))
    (apply-operator sup
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="inf"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="h-o-real-arithmetic" name="rr"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sum-inequality-macete"  type="theorem">
<CMP>
 Theorem name: "sum-inequality-macete". <with style="linebreak"/>

 Formula (string): "forall(x,y,z,u:rr,x&lt;=z and y&lt;=u implies x+y&lt;=z+u)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y z u))
 (implies (and (apply-operator &lt;= x z) (apply-operator &lt;= y u))
  (apply-operator &lt;= (apply-operator + x y) (apply-operator + z u))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="z"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="u"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="x"/>
       <om:OMV name="z"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="y"/>
       <om:OMV name="u"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMV name="z"/>
       <om:OMV name="u"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sup-minus-epsilon"  type="theorem">
<CMP>
 Theorem name: "sup-minus-epsilon". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],eps:rr,
  0&lt;eps implies not(sup(s)-eps majorizes s))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr eps))
 (implies (apply-operator &lt; 0 eps)
  (not
   (apply-operator majorizes (apply-operator sub (apply-operator sup s) eps)
    s))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="eps"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
      <om:OMV name="eps"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="not"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="majorizes"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMA>
         <om:OMS cd="partial-order" name="sup"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sup-minus-epsilon-corollary"  type="theorem">
<CMP>
 Theorem name: "sup-minus-epsilon-corollary". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],eps:rr,
  0&lt;eps and #(sup(s))
   implies 
  forsome(x:rr,x in s and sup(s)-eps&lt;x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr eps))
 (implies (and (apply-operator &lt; 0 eps) (is-defined (apply-operator sup s)))
  (forsome ((rr x))
   (and (i-in x s)
    (apply-operator &lt; (apply-operator sub (apply-operator sup s) eps) x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="eps"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="eps"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="sup"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMV name="eps"/>
        </om:OMA>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing-sequences-converge"  type="theorem">
<CMP>
 Theorem name: "nondecreasing-sequences-converge". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],
  nondecreasing(f)
   and 
  forsome(n:zz,forall(k:zz,n&lt;=k implies #(f(k))))
   and 
  #(sup(ran{f}))
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(k:zz,
      forall(j:zz,k&lt;=j implies sup(ran{f})-f(j)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f))
 (implies
  (and (apply-operator nondecreasing f)
   (forsome ((zz n))
    (forall ((zz k))
     (implies (apply-operator &lt;= n k) (is-defined (apply-operator f k)))))
   (is-defined (apply-operator sup (m-range f))))
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz k))
     (forall ((zz j))
      (implies (apply-operator &lt;= k j)
       (apply-operator &lt;=
        (apply-operator sub (apply-operator sup (m-range f))
         (apply-operator f j))
        eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="nondecreasing"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="n"/>
          <om:OMV name="k"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="f"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMV name="k"/>
           <om:OMV name="j"/>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sub"/>
            <om:OMA>
             <om:OMS cd="partial-order" name="sup"/>
             <om:OMA>
              <om:OMS cd="the-kernel-theory" name="m-range"/>
              <om:OMV name="f"/>
             </om:OMA>
            </om:OMA>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j"/>
            </om:OMA>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing-sequences-converge-corollary"  type="theorem">
<CMP>
 Theorem name: "nondecreasing-sequences-converge-corollary". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],
  nondecreasing(f)
   and 
  forsome(n:zz,forall(k:zz,n&lt;=k implies #(f(k))))
   and 
  #(sup(ran{f}))
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(k:zz,
      forall(j,j_1:zz,
        k&lt;=j and j&lt;=j_1 implies f(j_1)-f(j)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f))
 (implies
  (and (apply-operator nondecreasing f)
   (forsome ((zz n))
    (forall ((zz k))
     (implies (apply-operator &lt;= n k) (is-defined (apply-operator f k)))))
   (is-defined (apply-operator sup (m-range f))))
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz k))
     (forall ((zz j j_1))
      (implies (and (apply-operator &lt;= k j) (apply-operator &lt;= j j_1))
       (apply-operator &lt;=
        (apply-operator sub (apply-operator f j_1) (apply-operator f j))
        eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="nondecreasing"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="n"/>
          <om:OMV name="k"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="f"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j_1"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="and"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="k"/>
            <om:OMV name="j"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
           </om:OMA>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sub"/>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j_1"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j"/>
            </om:OMA>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sum-interval-additivity"  type="theorem">
<CMP>
 Theorem name: "sum-interval-additivity". <with style="linebreak"/>

 Formula (string): 
"forall(m,n,p:zz,f:[zz,rr],
  m&lt;=n and n&lt;=p implies sum(m,n,f)+sum(n+1,p,f)==sum(m,p,f))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz m n p) ((zz rr) f))
 (implies (and (apply-operator &lt;= m n) (apply-operator &lt;= n p))
  (==
   (apply-operator + (apply-operator sum m n f)
    (apply-operator sum (apply-operator + n 1) p f))
   (apply-operator sum m p f))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="m"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="m"/>
       <om:OMV name="n"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="n"/>
       <om:OMV name="p"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="=="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMV name="m"/>
        <om:OMV name="n"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="+"/>
         <om:OMV name="n"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
        </om:OMA>
        <om:OMV name="p"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="m"/>
       <om:OMV name="p"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sum-nonnegativity"  type="theorem">
<CMP>
 Theorem name: "sum-nonnegativity". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],a,b:zz,
  forall(z:zz,a&lt;=z and z&lt;=b implies 0&lt;=f(z))
   implies 
  0&lt;=sum(a,b,f))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f) (zz a b))
 (implies
  (forall ((zz z))
   (implies (and (apply-operator &lt;= a z) (apply-operator &lt;= z b))
    (apply-operator &lt;= 0 (apply-operator f z))))
  (apply-operator &lt;= 0 (apply-operator sum a b f))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="z"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="a"/>
         <om:OMV name="z"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="z"/>
         <om:OMV name="b"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMA>
         <om:OMV name="f"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing%sums"  type="theorem">
<CMP>
 Theorem name: "nondecreasing%sums". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,rr],k:zz,
  forall(n:zz,k&lt;=n implies 0&lt;=s(n))
   implies 
  nondecreasing(lambda(p:zz,sum(k,p,s))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) s) (zz k))
 (implies
  (forall ((zz n))
   (implies (apply-operator &lt;= k n)
    (apply-operator &lt;= 0 (apply-operator s n))))
  (apply-operator nondecreasing (lambda ((zz p)) (apply-operator sum k p s)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="k"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="k"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="partial-order" name="nondecreasing"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="p"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMV name="k"/>
        <om:OMV name="p"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="summable%nonnegative" kind="object">
<CMP> "summable%nonnegative" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="summable%nonnegative-def"  for="summable%nonnegative"  type="simple">
<CMP>
 Symbol name: "summable%nonnegative". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forsome(k:zz,
    forall(n:zz,
      k&lt;=n
       implies 
      0&lt;=s(n) and #(sup(ran{lambda(p:zz,sum(k,p,s))})))))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forsome ((zz k))
  (forall ((zz n))
   (implies (apply-operator &lt;= k n)
    (and (apply-operator &lt;= 0 (apply-operator s n))
     (is-defined
      (apply-operator sup
       (m-range (lambda ((zz p)) (apply-operator sum k p s))))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="k"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="k"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMS cd="h-o-real-arithmetic" name="0"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMS cd="partial-order" name="sup"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="m-range"/>
           <om:OMBIND>
            <om:OMS cd="the-kernel-theory" name="lambda"/>
            <om:OMBVAR>

             <om:OMATTR>
              <om:OMATP>
               <om:OMS cd="the-kernel-theory" name="sort"/>
               <om:OMS cd="h-o-real-arithmetic" name="zz"/>
              </om:OMATP>
              <om:OMV name="p"/>
             </om:OMATTR>

            </om:OMBVAR>

            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="sum"/>
             <om:OMV name="k"/>
             <om:OMV name="p"/>
             <om:OMV name="s"/>
            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="small%tails%of%summable%nonnegative%sequence"  type="theorem">
<CMP>
 Theorem name: "small%tails%of%summable%nonnegative%sequence". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,rr],
  summable%nonnegative(s)
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(p:zz,
      forall(j,j_1:zz,
        p&lt;=j and j&lt;=j_1 implies sum(j,j_1,s)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) s))
 (implies (apply-operator summable%nonnegative s)
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz p))
     (forall ((zz j j_1))
      (implies (and (apply-operator &lt;= p j) (apply-operator &lt;= j j_1))
       (apply-operator &lt;= (apply-operator sum j j_1 s) eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="partial-order" name="summable%nonnegative"/>
      <om:OMV name="s"/>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="p"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j_1"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="and"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="p"/>
            <om:OMV name="j"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
           </om:OMA>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sum"/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
            <om:OMV name="s"/>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="discrete%set" kind="object">
<CMP> "discrete%set" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="discrete%set-def"  for="discrete%set"  type="simple">
<CMP>
 Symbol name: "discrete%set". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  forsome(a:rr,0&lt;a and forall(x,y:rr,x&lt;y implies a&lt;=y-x)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (forsome ((rr a))
  (and (apply-operator &lt; 0 a)
   (forall ((rr x y))
    (implies (apply-operator &lt; x y)
     (apply-operator &lt;= a (apply-operator sub y x)))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="a"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="a"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMV name="y"/>
          <om:OMV name="x"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="discrete-sets-contain-sup-lemma"  type="theorem">
<CMP>
 Theorem name: "discrete-sets-contain-sup-lemma". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],
  discrete%set(s) and #(sup(s))
   implies 
  forsome(a:rr,
    0&lt;a
     and 
    forall(x:rr,x in s implies x=sup(s) or x&lt;=sup(s)-a)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s))
 (implies
  (and (apply-operator discrete%set s) (is-defined (apply-operator sup s)))
  (forsome ((rr a))
   (and (apply-operator &lt; 0 a)
    (forall ((rr x))
     (or (implies (i-in x s) (= x (apply-operator sup s)))
      (apply-operator &lt;= x (apply-operator sub (apply-operator sup s) a))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="a"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="x"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="or"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="i-in"/>
           <om:OMV name="x"/>
           <om:OMV name="s"/>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="="/>
           <om:OMV name="x"/>
           <om:OMA>
            <om:OMS cd="partial-order" name="sup"/>
            <om:OMV name="s"/>
           </om:OMA>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="x"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMA>
            <om:OMS cd="partial-order" name="sup"/>
            <om:OMV name="s"/>
           </om:OMA>
           <om:OMV name="a"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="empty-indic-sup-is-undefined"  type="theorem">
<CMP>
 Theorem name: "empty-indic-sup-is-undefined". <with style="linebreak"/>

 Formula (string): "not(#(sup(empty_indic{rr})))". <with style="linebreak"/>

 Formula (s-expression): "(not (is-defined (apply-operator sup (i-empty-indicator (undefined rr)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="not"/>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="is-defined"/>
     <om:OMA>
      <om:OMS cd="partial-order" name="sup"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-empty-indicator"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="undefined"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>

       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="discrete-sets-contain-sup"  type="theorem">
<CMP>
 Theorem name: "discrete-sets-contain-sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],
  discrete%set(s) and #(sup(s)) implies sup(s) in s)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s))
 (implies
  (and (apply-operator discrete%set s) (is-defined (apply-operator sup s)))
  (i-in (apply-operator sup s) s)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="preceding" kind="object">
<CMP> "preceding" - defined constant in the theory "partial-order". </CMP>
</symbol>

<definition xml:id="preceding-def"  for="preceding"  type="simple">
<CMP>
 Symbol name: "preceding". <with style="linebreak"/>

 String defining expression: "lambda(s:sets[rr],a:rr,sup(indic{x:rr,  x in s and x&lt;a}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s) (rr a))
 (apply-operator sup
  (predicate-to-indicator
   (lambda ((rr x)) (and (i-in x s) (apply-operator &lt; x a))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="partial-order" name="sup"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="predicate-to-indicator"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="i-in"/>
         <om:OMV name="x"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="x"/>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="preceding-for-discrete-sets"  type="theorem">
<CMP>
 Theorem name: "preceding-for-discrete-sets". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],x:rr,
  discrete%set(s) and #(preceding(s,x))
   implies 
  preceding(s,x) in s)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr x))
 (implies
  (and (apply-operator discrete%set s)
   (is-defined (apply-operator preceding s x)))
  (i-in (apply-operator preceding s x) s)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="partial-order" name="preceding"/>
        <om:OMV name="s"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="preceding"/>
       <om:OMV name="s"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="preceding-defined"  type="theorem">
<CMP>
 Theorem name: "preceding-defined". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],x:rr,
  #(preceding(s,x)) iff forsome(y:rr,y in s and y&lt;x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr x))
 (iff (is-defined (apply-operator preceding s x))
  (forsome ((rr y)) (and (i-in y s) (apply-operator &lt; y x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMS cd="partial-order" name="preceding"/>
       <om:OMV name="s"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMV name="y"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-formula"  type="theorem">
<CMP>
 Theorem name: "geometric-series-formula". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  0&lt;=p and p&lt;=q and not(r=0) and not(r=1)
   implies 
  sum(p,q,lambda(j:zz,r^j*a))=a*(r^p/(1-r))*(1-r^(q-p+1)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 0 p) (apply-operator &lt;= p q) (not (= r 0))
   (not (= r 1)))
  (=
   (apply-operator sum p q
    (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))
   (apply-operator *
    (apply-operator * a
     (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r)))
    (apply-operator sub 1
     (apply-operator ^ r (apply-operator + (apply-operator sub q p) 1)))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="not"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="r"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="not"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="r"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="j"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="*"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="j"/>
         </om:OMA>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="a"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="/"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="p"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
          <om:OMV name="r"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMV name="q"/>
           <om:OMV name="p"/>
          </om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-upper-estimate-lemma"  type="theorem">
<CMP>
 Theorem name: "geometric-series-upper-estimate-lemma". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  1&lt;=p and p&lt;=q and 0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  a*(r^p/(1-r))*(1-r^(q-p+1))&lt;=a*(r^p/(1-r)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 1 p) (apply-operator &lt;= p q) (apply-operator &lt; 0 r)
   (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator &lt;=
   (apply-operator *
    (apply-operator * a
     (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r)))
    (apply-operator sub 1
     (apply-operator ^ r (apply-operator + (apply-operator sub q p) 1))))
   (apply-operator * a
    (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="a"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="/"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="p"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
          <om:OMV name="r"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMV name="q"/>
           <om:OMV name="p"/>
          </om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="/"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
         <om:OMV name="r"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-upper-estimate"  type="theorem">
<CMP>
 Theorem name: "geometric-series-upper-estimate". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  1&lt;=p and p&lt;=q and 0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  sum(p,q,lambda(j:zz,r^j*a))&lt;=a*(r^p/(1-r)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 1 p) (apply-operator &lt;= p q) (apply-operator &lt; 0 r)
   (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator &lt;=
   (apply-operator sum p q
    (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))
   (apply-operator * a
    (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="j"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="*"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="j"/>
         </om:OMA>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="/"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
         <om:OMV name="r"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-is-summable%nonnegative"  type="theorem">
<CMP>
 Theorem name: "geometric-series-is-summable%nonnegative". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  summable%nonnegative(lambda(j:zz,r^j*a)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt; 0 r) (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator summable%nonnegative
   (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="partial-order" name="summable%nonnegative"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="j"/>
        </om:OMA>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


</omgroup>


<omgroup xml:id="translations-of-partial-order" type="sequence">
<metadata>
 <dc:title>Translations</dc:title>
</metadata>

<omtext xml:id="partial-order-translations-intro">
 <CMP>
  The translations that have theory "partial-order" as target theory.
</CMP>
</omtext>


<imports xml:id="index-on-zz" from="mappings-into-a-partial-order">
<CMP>
 Translation name: "index-on-zz". <with style="linebreak"/> 
 Source theory: "mappings-into-a-partial-order". <with style="linebreak"/>
 Target theory: "partial-order". <with style="linebreak"/>
 Fixed theories: "h-o-real-arithmetic". <with style="linebreak"/>
 Assumptions: none. <with style="linebreak"/>
 Sort pairs: "(ind_1 zz)", "(uu uu)". <with style="linebreak"/>
 Constant pairs: "(prec prec)". <with style="linebreak"/>
 Interpretation?: yes. <with style="linebreak"/>
</CMP>

<morphism>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="ind_1"/>
   </om:OMOBJ>
  </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="zz"/>
   </om:OMOBJ>
  </value>
 </requation>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="uu"/>
   </om:OMOBJ>
  </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="uu"/>
   </om:OMOBJ>
  </value>
 </requation>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="prec"/>
    </om:OMOBJ>
   </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="prec"/>
   </om:OMOBJ>
  </value>
 </requation>

</morphism>
</imports>

<imports xml:id="index-on-zz-reverse" from="mappings-into-a-partial-order">
<CMP>
 Translation name: "index-on-zz-reverse". <with style="linebreak"/> 
 Source theory: "mappings-into-a-partial-order". <with style="linebreak"/>
 Target theory: "partial-order". <with style="linebreak"/>
 Fixed theories: "h-o-real-arithmetic". <with style="linebreak"/>
 Assumptions: none. <with style="linebreak"/>
 Sort pairs: "(uu uu)", "(ind_1 zz)". <with style="linebreak"/>
 Constant pairs: "(prec rev%prec)", "(rev%prec prec)". <with style="linebreak"/>
 Interpretation?: yes. <with style="linebreak"/>
</CMP>

<morphism>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="uu"/>
   </om:OMOBJ>
  </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="uu"/>
   </om:OMOBJ>
  </value>
 </requation>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="ind_1"/>
   </om:OMOBJ>
  </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="zz"/>
   </om:OMOBJ>
  </value>
 </requation>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="prec"/>
    </om:OMOBJ>
   </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="rev%prec"/>
   </om:OMOBJ>
  </value>
 </requation>


 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="mappings-into-a-partial-order" name="rev%prec"/>
    </om:OMOBJ>
   </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="prec"/>
   </om:OMOBJ>
  </value>
 </requation>

</morphism>
</imports>

<imports xml:id="order-reverse" from="partial-order">
<CMP>
 Translation name: "order-reverse". <with style="linebreak"/> 
 Source theory: "partial-order". <with style="linebreak"/>
 Target theory: "partial-order". <with style="linebreak"/>
 Fixed theories: "h-o-real-arithmetic". <with style="linebreak"/>
 Assumptions: none. <with style="linebreak"/>
 Sort pairs: "(uu uu)". <with style="linebreak"/>
 Constant pairs: "(prec rev%prec)", "(rev%prec prec)". <with style="linebreak"/>
 Interpretation?: yes. <with style="linebreak"/>
</CMP>

<morphism>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="uu"/>
   </om:OMOBJ>
  </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="uu"/>
   </om:OMOBJ>
  </value>
 </requation>

 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="prec"/>
    </om:OMOBJ>
   </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="rev%prec"/>
   </om:OMOBJ>
  </value>
 </requation>


 <requation>
  <pattern>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="rev%prec"/>
    </om:OMOBJ>
   </pattern>

  <value>
   <om:OMOBJ>
    <om:OMS cd="partial-order" name="prec"/>
   </om:OMOBJ>
  </value>
 </requation>

</morphism>
</imports>
</omgroup>


</theory>

</omdoc>
