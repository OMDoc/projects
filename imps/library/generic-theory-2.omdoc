<?xml version="1.0"?>
<!DOCTYPE omdoc PUBLIC "-//OMDoc//DTD OMDoc V1.2//EN" "../dtd/omdoc-basic.dtd" [<!ENTITY % om.prefixed "INCLUDE">]>

<omdoc xml:id="GENERIC-THEORY-2-omdoc"
       xmlns="http://www.mathweb.org/omdoc"
       xmlns:dc="http://dublincore.org"
       xmlns:om="http://www.openmath.org/OpenMath">

<metadata>
 <dc:title>The theory GENERIC-THEORY-2 in IMPS</dc:title>
 <dc:source>
  <dc:title>IMPS: An Interactive Mathematical Proof System</dc:title>
  <dc:creator role="aut">W.M. Farmer</dc:creator>
  <dc:creator role="aut">J.D. Guttman</dc:creator>
  <dc:creator role="aut">F.J. Thayer</dc:creator>
  <dc:date action="created">2001</dc:date>
 </dc:source>
 <dc:creator role="aut">W.M. Farmer</dc:creator>
 <dc:creator role="aut">J.D. Guttman</dc:creator>
 <dc:creator role="aut">F.J. Thayer</dc:creator>
 <dc:contributor role="trl">Yan Li</dc:contributor>
 <dc:contributor role="edt">Marc Bender</dc:contributor>
 <dc:date action="created">2002</dc:date>
 <dc:date action="updated">2005</dc:date>
</metadata>


<theory xml:id="generic-theory-2">

<omgroup xml:id="generic-theory-2-component-theories" type="sequence">
<metadata>
 <dc:title>Component theories</dc:title>
</metadata>


<imports xml:id="generic-theory-1.import"  from="generic-theory-1"/>
<omtext xml:id="generic-theory-1.import-display">
 <CMP>
 "generic-theory-1" - component theory of "generic-theory-2".
 </CMP>
</omtext>


<imports xml:id="pure-generic-theory-2.import"  from="pure-generic-theory-2"/>
<omtext xml:id="pure-generic-theory-2.import-display">
 <CMP>
 "pure-generic-theory-2" - component theory of "generic-theory-2".
 </CMP>
</omtext>


<imports xml:id="h-o-real-arithmetic.import"  from="h-o-real-arithmetic"/>
<omtext xml:id="h-o-real-arithmetic.import-display">
 <CMP>
 "h-o-real-arithmetic" - component theory of "generic-theory-2".
 </CMP>
</omtext>

</omgroup>




<omgroup xml:id="events-of-generic-theory-2" type="sequence">
<metadata>
 <dc:title>Events</dc:title>
</metadata>

<omtext xml:id="generic-theory-2-events-intro">
 <CMP>
  The events of the theory "generic-theory-2" in load order.
 </CMP>
</omtext>


<assertion xml:id="unary-eta-reduction"  type="theorem">
<CMP>
 Theorem name: "unary-eta-reduction". <with style="linebreak"/>

 Formula (string): "forall(f:[ind_1,ind_2],lambda(x:ind_1,f(x))=f)". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 ind_2) f)) (= (lambda ((ind_1 x)) (apply-operator f x)) f))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="lambda"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMBIND>
     <om:OMV name="f"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="domain-membership-iff-defined"  type="theorem">
<CMP>
 Theorem name: "domain-membership-iff-defined". <with style="linebreak"/>

 Formula (string): "forall(x:ind_1,f:[ind_1,ind_2],x in dom{f} iff #(f(x)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) ((ind_1 ind_2) f))
 (iff (i-in x (m-domain f)) (is-defined (apply-operator f x))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="rev%domain-membership-iff-defined"  type="theorem">
<CMP>
 Theorem name: "rev%domain-membership-iff-defined". <with style="linebreak"/>

 Formula (string): "forall(x:ind_1,f:[ind_1,ind_2],#(f(x)) iff x in dom{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) ((ind_1 ind_2) f))
 (iff (is-defined (apply-operator f x)) (i-in x (m-domain f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="range-domain-membership"  type="theorem">
<CMP>
 Theorem name: "range-domain-membership". <with style="linebreak"/>

 Formula (string): 
"forall(x:ind_1,f:[ind_1,ind_2],
  f(x) in ran{f} iff x in dom{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) ((ind_1 ind_2) f))
 (iff (i-in (apply-operator f x) (m-range f)) (i-in x (m-domain f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete", "transportable-rewrite". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="rev%range-domain-membership"  type="theorem">
<CMP>
 Theorem name: "rev%range-domain-membership". <with style="linebreak"/>

 Formula (string): 
"forall(x:ind_1,f:[ind_1,ind_2],
  x in dom{f} iff f(x) in ran{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) ((ind_1 ind_2) f))
 (iff (i-in x (m-domain f)) (i-in (apply-operator f x) (m-range f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="membership-in-a-domain"  type="theorem">
<CMP>
 Theorem name: "membership-in-a-domain". <with style="linebreak"/>

 Formula (string): 
"forall(x:ind_1,a:sets[ind_1],f:[ind_1,ind_2],
  dom{f}=a and #(f(x)) implies x in a)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) ((ind_1 unit%sort) a) ((ind_1 ind_2) f))
 (implies (and (= (m-domain f) a) (is-defined (apply-operator f x)))
  (i-in x a)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-domain"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="membership-in-a-range"  type="theorem">
<CMP>
 Theorem name: "membership-in-a-range". <with style="linebreak"/>

 Formula (string): 
"forall(x:ind_1,y:ind_2,b:sets[ind_2],f:[ind_1,ind_2],
  ran{f}=b and y=f(x) implies y in b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind_1 x) (ind_2 y) ((ind_2 unit%sort) b) ((ind_1 ind_2) f))
 (implies (and (= (m-range f) b) (= y (apply-operator f x))) (i-in y b)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-range"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMV name="y"/>
       <om:OMA>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="y"/>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="dom-of-an-indicator"  type="theorem">
<CMP>
 Theorem name: "dom-of-an-indicator". <with style="linebreak"/>

 Formula (string): "forall(a:sets[ind_1],dom{a}=a)". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 unit%sort) a)) (= (m-domain a) a))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-domain"/>
      <om:OMV name="a"/>
     </om:OMA>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="image-of-domain-is-range"  type="theorem">
<CMP>
 Theorem name: "image-of-domain-is-range". <with style="linebreak"/>

 Formula (string): "forall(f:[ind_1,ind_2],image{f,dom{f}}=ran{f})". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 ind_2) f)) (= (m-image f (m-domain f)) (m-range f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-image"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="image-subset-of-range-characterization"  type="theorem">
<CMP>
 Theorem name: "image-subset-of-range-characterization". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[ind_1],f:[ind_1,ind_2],
  s subseteq dom{f} implies image{f,s} subseteq ran{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 unit%sort) s) ((ind_1 ind_2) f))
 (implies (i-subseteq s (m-domain f)) (i-subseteq (m-image f s) (m-range f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMV name="s"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-image"/>
       <om:OMV name="f"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="image-is-monotone-wrt-subseteq"  type="theorem">
<CMP>
 Theorem name: "image-is-monotone-wrt-subseteq". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a,b:sets[ind_1],
  a subseteq b implies image{f,a} subseteq image{f,b})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a b))
 (implies (i-subseteq a b) (i-subseteq (m-image f a) (m-image f b))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMV name="a"/>
      <om:OMV name="b"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-image"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-image"/>
       <om:OMV name="f"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="direct-image-disjointness-conversion"  type="theorem">
<CMP>
 Theorem name: "direct-image-disjointness-conversion". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],b:sets[ind_2],
  empty_indic_q{b inters image{f,a}}
   iff 
  empty_indic_q{inv_image{f,b} inters a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a) ((ind_2 unit%sort) b))
 (iff (i-empty-indicator? (i-intersection b (m-image f a)))
  (i-empty-indicator? (i-intersection (m-inverse-image f b) a))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-empty-indicator?"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-intersection"/>
       <om:OMV name="b"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-image"/>
        <om:OMV name="f"/>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-empty-indicator?"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-intersection"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
        <om:OMV name="f"/>
        <om:OMV name="b"/>
       </om:OMA>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="direct-image-subset-conversion"  type="theorem">
<CMP>
 Theorem name: "direct-image-subset-conversion". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],b:sets[ind_2],
  total_q{f,[ind_1,ind_2]}
   implies 
  image{f,a} subseteq b iff a subseteq inv_image{f,b})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a) ((ind_2 unit%sort) b))
 (implies (total? f (undefined (ind_1 ind_2)))
  (iff (i-subseteq (m-image f a) b) (i-subseteq a (m-inverse-image f b)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="iff"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-image"/>
        <om:OMV name="f"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
        <om:OMV name="f"/>
        <om:OMV name="b"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-image-union-preservation"  type="theorem">
<CMP>
 Theorem name: "inverse-image-union-preservation". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a,b:sets[ind_2],
  inv_image{f,a union b}
  =inv_image{f,a} union inv_image{f,b})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_2 unit%sort) a b))
 (= (m-inverse-image f (i-union a b))
  (i-union (m-inverse-image f a) (m-inverse-image f b))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-union"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-union"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-image-inters-preservation"  type="theorem">
<CMP>
 Theorem name: "inverse-image-inters-preservation". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a,b:sets[ind_2],
  inv_image{f,a inters b}
  =inv_image{f,a} inters inv_image{f,b})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_2 unit%sort) a b))
 (= (m-inverse-image f (i-intersection a b))
  (i-intersection (m-inverse-image f a) (m-inverse-image f b))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-intersection"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-intersection"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="b"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="meaning-of-inverse-image-membership"  type="theorem">
<CMP>
 Theorem name: "meaning-of-inverse-image-membership". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],x:ind_1,o:sets[ind_2],
  x in inv_image{f,o} iff f(x) in o)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) (ind_1 x) ((ind_2 unit%sort) o))
 (iff (i-in x (m-inverse-image f o)) (i-in (apply-operator f x) o)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="o"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMV name="x"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="o"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="o"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="dom-of-id"  type="theorem">
<CMP>
 Theorem name: "dom-of-id". <with style="linebreak"/>

 Formula (string): "forall(a:sets[ind_1],dom{id{a}}=a)". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 unit%sort) a)) (= (m-domain (m-id a)) a))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-domain"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="ran-of-id"  type="theorem">
<CMP>
 Theorem name: "ran-of-id". <with style="linebreak"/>

 Formula (string): "forall(a:sets[ind_1],ran{id{a}}=a)". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 unit%sort) a)) (= (m-range (m-id a)) a))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="id-is-injective-on-dom"  type="theorem">
<CMP>
 Theorem name: "id-is-injective-on-dom". <with style="linebreak"/>

 Formula (string): "forall(a:sets[ind_1],injective_on_q{id{a},a})". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 unit%sort) a)) (m-injective-on? (m-id a) a))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="m-injective-on?"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-id"/>
      <om:OMV name="a"/>
     </om:OMA>
     <om:OMV name="a"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="composition-with-id-right"  type="theorem">
<CMP>
 Theorem name: "composition-with-id-right". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],
  f oo (id{a})=restrict{f,a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a))
 (= (m-composition f (m-id a)) (m-restrict f a)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete", "transportable-rewrite". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-composition"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-restrict"/>
      <om:OMV name="f"/>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="composition-with-id-left"  type="theorem">
<CMP>
 Theorem name: "composition-with-id-left". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_2],
  (id{a}) oo f=restrict{f,inv_image{f,a}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_2 unit%sort) a))
 (= (m-composition (m-id a) f) (m-restrict f (m-inverse-image f a))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete", "transportable-rewrite". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-composition"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-restrict"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="composition-with-total-id-left"  type="theorem">
<CMP>
 Theorem name: "composition-with-total-id-left". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_2],
  total_q{a,sets[ind_2]} implies (id{a}) oo f=f)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_2 unit%sort) a))
 (implies (total? a (undefined (ind_2 unit%sort)))
  (= (m-composition (m-id a) f) f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="a"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-composition"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-id"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="composition-with-total-id-right"  type="theorem">
<CMP>
 Theorem name: "composition-with-total-id-right". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],
  total_q{a,sets[ind_1]} implies f oo (id{a})=f)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a))
 (implies (total? a (undefined (ind_1 unit%sort)))
  (= (m-composition f (m-id a)) f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="a"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-composition"/>
       <om:OMV name="f"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-id"/>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMA>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="surjective-on-lemma"  type="theorem">
<CMP>
 Theorem name: "surjective-on-lemma". <with style="linebreak"/>

 Formula (string): 
"forall(a:sets[ind_1],b:sets[ind_2],f:[ind_1,ind_2],x:ind_1,
  surjective_on_q{f,a,b} and x in a implies f(x) in b)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall
 (((ind_1 unit%sort) a) ((ind_2 unit%sort) b) ((ind_1 ind_2) f) (ind_1 x))
 (implies (and (m-surjective-on? f a b) (i-in x a))
  (i-in (apply-operator f x) b)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-surjective-on?"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="b"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="injective-and-surjective-is-total"  type="theorem">
<CMP>
 Theorem name: "injective-and-surjective-is-total". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} and surjective_q{f}
   implies 
  total_q{f,[ind_1,ind_2]})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (and (m-injective? f) (m-surjective? f))
  (total? f (undefined (ind_1 ind_2)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-injective?"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-surjective?"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="injective-implies-injective-on"  type="theorem">
<CMP>
 Theorem name: "injective-implies-injective-on". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],
  injective_q{f} implies injective_on_q{f,a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a))
 (implies (m-injective? f) (m-injective-on? f a)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective-on?"/>
      <om:OMV name="f"/>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="injective-iff-injective-on-domain"  type="theorem">
<CMP>
 Theorem name: "injective-iff-injective-on-domain". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],
  injective_q{f} iff injective_on_q{f,dom{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a))
 (iff (m-injective? f) (m-injective-on? f (m-domain f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective-on?"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="range-of-bijection-on-singleton"  type="theorem">
<CMP>
 Theorem name: "range-of-bijection-on-singleton". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],b:sets[ind_2],
  bijective_on_q{f,a,b} and forsome(x:ind_1,a=singleton{x})
   implies 
  forsome(y:ind_2,b=singleton{y}))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a) ((ind_2 unit%sort) b))
 (implies
  (and (m-bijective-on? f a b) (forsome ((ind_1 x)) (= a (i-singleton x))))
  (forsome ((ind_2 y)) (= b (i-singleton y)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-bijective-on?"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="a"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="i-singleton"/>
         <om:OMV name="x"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMV name="b"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-singleton"/>
        <om:OMV name="y"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="domain-of-a-restriction"  type="theorem">
<CMP>
 Theorem name: "domain-of-a-restriction". <with style="linebreak"/>

 Formula (string): 
"forall(phi:[ind_1,ind_2],s:sets[ind_1],
  s subseteq dom{phi} implies s=dom{restrict{phi,s}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) phi) ((ind_1 unit%sort) s))
 (implies (i-subseteq s (m-domain phi)) (= s (m-domain (m-restrict phi s)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="phi"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMV name="s"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="phi"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="s"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-restrict"/>
        <om:OMV name="phi"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="image-of-a-restriction"  type="theorem">
<CMP>
 Theorem name: "image-of-a-restriction". <with style="linebreak"/>

 Formula (string): 
"forall(phi:[ind_1,ind_2],s:sets[ind_1],
  image{restrict{phi,s},s}=image{phi,s})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) phi) ((ind_1 unit%sort) s))
 (= (m-image (m-restrict phi s) s) (m-image phi s)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="phi"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-image"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-restrict"/>
       <om:OMV name="phi"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-image"/>
      <om:OMV name="phi"/>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="injectivity-of-a-restriction"  type="theorem">
<CMP>
 Theorem name: "injectivity-of-a-restriction". <with style="linebreak"/>

 Formula (string): 
"forall(phi:[ind_1,ind_2],s:sets[ind_1],
  injective_q{phi} implies injective_q{restrict{phi,s}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) phi) ((ind_1 unit%sort) s))
 (implies (m-injective? phi) (m-injective? (m-restrict phi s))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="phi"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="phi"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-restrict"/>
       <om:OMV name="phi"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-composes-to-id"  type="theorem">
<CMP>
 Theorem name: "inverse-composes-to-id". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  (inverse{f}) oo f=id{ran{inverse{f}}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (= (m-composition (m-inverse f) f) (m-id (m-range (m-inverse f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-composition"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-id"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-is-injective"  type="theorem">
<CMP>
 Theorem name: "inverse-is-injective". <with style="linebreak"/>

 Formula (string): "forall(f:[ind_1,ind_2],injective_q{inverse{f}})". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 ind_2) f)) (m-injective? (m-inverse f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="m-injective?"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-inverse"/>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-defined-within-range"  type="theorem">
<CMP>
 Theorem name: "inverse-defined-within-range". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies ran{f} subseteq dom{inverse{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f) (i-subseteq (m-range f) (m-domain (m-inverse f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-defined-only-in-range"  type="theorem">
<CMP>
 Theorem name: "inverse-defined-only-in-range". <with style="linebreak"/>

 Formula (string): "forall(f:[ind_1,ind_2],dom{inverse{f}} subseteq ran{f})". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 ind_2) f)) (i-subseteq (m-domain (m-inverse f)) (m-range f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-domain"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="dom-of-inverse"  type="theorem">
<CMP>
 Theorem name: "dom-of-inverse". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies dom{inverse{f}}=ran{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f) (= (m-domain (m-inverse f)) (m-range f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-range-within-domain"  type="theorem">
<CMP>
 Theorem name: "inverse-range-within-domain". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies dom{f} subseteq ran{inverse{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f) (i-subseteq (m-domain f) (m-range (m-inverse f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-range-only-in-domain"  type="theorem">
<CMP>
 Theorem name: "inverse-range-only-in-domain". <with style="linebreak"/>

 Formula (string): "forall(f:[ind_1,ind_2],ran{inverse{f}} subseteq dom{f})". <with style="linebreak"/>

 Formula (s-expression): "(forall (((ind_1 ind_2) f)) (i-subseteq (m-range (m-inverse f)) (m-domain f)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-domain"/>
      <om:OMV name="f"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="ran-of-inverse"  type="theorem">
<CMP>
 Theorem name: "ran-of-inverse". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies ran{inverse{f}}=dom{f})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f) (= (m-range (m-inverse f)) (m-domain f))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-domain"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-is-a-left-inverse"  type="theorem">
<CMP>
 Theorem name: "inverse-is-a-left-inverse". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies (inverse{f}) oo f=id{dom{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f)
  (= (m-composition (m-inverse f) f) (m-id (m-domain f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-composition"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-domain"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-is-a-left-inverse-applied"  type="theorem">
<CMP>
 Theorem name: "inverse-is-a-left-inverse-applied". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],x:ind_1,
  injective_q{f} and #(f(x)) implies inverse{f}(f(x))=x)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) (ind_1 x))
 (implies (and (m-injective? f) (is-defined (apply-operator f x)))
  (= (apply-operator (m-inverse f) (apply-operator f x)) x)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-injective?"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
      <om:OMV name="x"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-is-a-right-inverse"  type="theorem">
<CMP>
 Theorem name: "inverse-is-a-right-inverse". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f} implies f oo (inverse{f})=id{ran{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f)
  (= (m-composition f (m-inverse f)) (m-id (m-range f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-composition"/>
       <om:OMV name="f"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-id"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-range"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-is-a-right-inverse-applied"  type="theorem">
<CMP>
 Theorem name: "inverse-is-a-right-inverse-applied". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],x:ind_2,
  injective_q{f} and x in ran{f} implies f(inverse{f}(x))=x)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) (ind_2 x))
 (implies (and (m-injective? f) (i-in x (m-range f)))
  (= (apply-operator f (apply-operator (m-inverse f) x)) x)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-injective?"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-range"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMV name="f"/>
       <om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-inverse"/>
         <om:OMV name="f"/>
        </om:OMA>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
      <om:OMV name="x"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="image-under-inverse-of-injective-mapping"  type="theorem">
<CMP>
 Theorem name: "image-under-inverse-of-injective-mapping". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],a:sets[ind_1],b:sets[ind_2],
  injective_q{f} and image{f,a}=b and a subseteq dom{f}
   implies 
  image{inverse{f},b}=a)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) ((ind_1 unit%sort) a) ((ind_2 unit%sort) b))
 (implies
  (and (m-injective? f) (= (m-image f a) b) (i-subseteq a (m-domain f)))
  (= (m-image (m-inverse f) b) a)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-injective?"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-image"/>
        <om:OMV name="f"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-subseteq"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-domain"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-image"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-inverse-is-restriction"  type="theorem">
<CMP>
 Theorem name: "inverse-inverse-is-restriction". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],
  injective_q{f}
   implies 
  inverse{inverse{f}}=restrict{f,dom{f}})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f))
 (implies (m-injective? f)
  (= (m-inverse (m-inverse f)) (m-restrict f (m-domain f)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-injective?"/>
      <om:OMV name="f"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-restrict"/>
       <om:OMV name="f"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-domain"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="surjective-inverse"  type="theorem">
<CMP>
 Theorem name: "surjective-inverse". <with style="linebreak"/>

 Formula (string): 
"forall(a:sets[ind_1],f:[ind_1,ind_2],
  injective_on_q{f,a} and dom{f}=a
   implies 
  surjective_on_q{inverse{f},ran{f},a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 unit%sort) a) ((ind_1 ind_2) f))
 (implies (and (m-injective-on? f a) (= (m-domain f) a))
  (m-surjective-on? (m-inverse f) (m-range f) a)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-injective-on?"/>
       <om:OMV name="f"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-domain"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-surjective-on?"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-inverse"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMV name="a"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-defined-only-in-range-existential"  type="theorem">
<CMP>
 Theorem name: "inverse-defined-only-in-range-existential". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_2],y:ind_2,
  #(inverse{f}(y)) implies forsome(x:ind_1,y=f(x)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) f) (ind_2 y))
 (implies (is-defined (apply-operator (m-inverse f) y))
  (forsome ((ind_1 x)) (= y (apply-operator f x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-inverse"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMV name="y"/>
       <om:OMA>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="archimedean"  type="theorem">
<CMP>
 Theorem name: "archimedean". <with style="linebreak"/>

 Formula (string): "forall(a:rr,forsome(n:zz,a&lt;n))". <with style="linebreak"/>

 Formula (s-expression): "(forall ((rr a)) (forsome ((zz n)) (apply-operator &lt; a n)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMV name="a"/>
      <om:OMV name="n"/>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="convergent%to%infinity" kind="object">
<CMP> "convergent%to%infinity" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="convergent%to%infinity-def"  for="convergent%to%infinity"  type="simple">
<CMP>
 Symbol name: "convergent%to%infinity". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forall(m:rr,
    forsome(x:zz,forall(j:zz,x&lt;=j implies m&lt;=s(j)))))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forall ((rr m))
  (forsome ((zz x))
   (forall ((zz j))
    (implies (apply-operator &lt;= x j)
     (apply-operator &lt;= m (apply-operator s j)))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="m"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="x"/>
         <om:OMV name="j"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="m"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="j"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMBIND>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="convergent%to%infinity-linear-form"  type="theorem">
<CMP>
 Theorem name: "convergent%to%infinity-linear-form". <with style="linebreak"/>

 Formula (string): 
"forall(a,b:rr,
  0&lt;a implies convergent%to%infinity(lambda(j:zz,a*j+b)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a b))
 (implies (apply-operator &lt; 0 a)
  (apply-operator convergent%to%infinity
   (lambda ((zz j)) (apply-operator + (apply-operator * a j) b)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
      <om:OMV name="a"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="convergent%to%infinity"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="+"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="*"/>
         <om:OMV name="a"/>
         <om:OMV name="j"/>
        </om:OMA>
        <om:OMV name="b"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="bernoullis-inequality"  type="theorem">
<CMP>
 Theorem name: "bernoullis-inequality". <with style="linebreak"/>

 Formula (string): "forall(h:rr,n:zz,-1&lt;h and 1&lt;=n implies 1+n*h&lt;=(1+h)^n)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr h) (zz n))
 (implies
  (and (apply-operator &lt; (apply-operator - 1) h) (apply-operator &lt;= 1 n))
  (apply-operator &lt;= (apply-operator + 1 (apply-operator * n h))
   (apply-operator ^ (apply-operator + 1 h) n))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="h"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="-"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
       </om:OMA>
       <om:OMV name="h"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="n"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="n"/>
        <om:OMV name="h"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="^"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="+"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMV name="h"/>
       </om:OMA>
       <om:OMV name="n"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="unbounded-heredity"  type="theorem">
<CMP>
 Theorem name: "unbounded-heredity". <with style="linebreak"/>

 Formula (string): 
"forall(s,t:[zz,rr],
  convergent%to%infinity(s)
   and 
  forsome(m:zz,forall(n:zz,m&lt;=n implies s(n)&lt;=t(n)))
   implies 
  convergent%to%infinity(t))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) s t))
 (implies
  (and (apply-operator convergent%to%infinity s)
   (forsome ((zz m))
    (forall ((zz n))
     (implies (apply-operator &lt;= m n)
      (apply-operator &lt;= (apply-operator s n) (apply-operator t n))))))
  (apply-operator convergent%to%infinity t)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="t"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="convergent%to%infinity"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="m"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="m"/>
          <om:OMV name="n"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMA>
           <om:OMV name="s"/>
           <om:OMV name="n"/>
          </om:OMA>
          <om:OMA>
           <om:OMV name="t"/>
           <om:OMV name="n"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="convergent%to%infinity"/>
      <om:OMV name="t"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="r^n-convergent-to-infinity"  type="theorem">
<CMP>
 Theorem name: "r^n-convergent-to-infinity". <with style="linebreak"/>

 Formula (string): 
"forall(r:rr,
  1&lt;r implies convergent%to%infinity(lambda(n:zz,r^n)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr r))
 (implies (apply-operator &lt; 1 r)
  (apply-operator convergent%to%infinity
   (lambda ((zz n)) (apply-operator ^ r n)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMS cd="h-o-real-arithmetic" name="1"/>
      <om:OMV name="r"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="convergent%to%infinity"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="^"/>
        <om:OMV name="r"/>
        <om:OMV name="n"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="complete-induction"  type="theorem">
<CMP>
 Theorem name: "complete-induction". <with style="linebreak"/>

 Formula (string): 
"forall(p:[zz,prop],n:zz,
  forall(m:zz,
    n&lt;=m and forall(k:zz,n&lt;=k and k&lt;m implies p(k))
     implies 
    p(m))
   implies 
  forall(k:zz,n&lt;=k implies p(k)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz prop) p) (zz n))
 (implies
  (forall ((zz m))
   (implies
    (and (apply-operator &lt;= n m)
     (forall ((zz k))
      (implies (and (apply-operator &lt;= n k) (apply-operator &lt; k m))
       (apply-operator p k))))
    (apply-operator p m)))
  (forall ((zz k)) (implies (apply-operator &lt;= n k) (apply-operator p k)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="prop"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="m"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="m"/>
        </om:OMA>
        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="k"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="and"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="k"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
            <om:OMV name="k"/>
            <om:OMV name="m"/>
           </om:OMA>
          </om:OMA>
          <om:OMA>
           <om:OMV name="p"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
       <om:OMA>
        <om:OMV name="p"/>
        <om:OMV name="m"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="k"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="k"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="p"/>
        <om:OMV name="k"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="complete-induction-schema"  type="theorem">
<CMP>
 Theorem name: "complete-induction-schema". <with style="linebreak"/>

 Formula (string): 
"forall(p:[zz,prop],n:zz,
  forall(k:zz,n&lt;=k implies p(k))
   iff 
  (truth
   and 
  forall(m:zz,
    n&lt;=m and forall(k:zz,n&lt;=k and k&lt;m implies p(k))
     implies 
    p(m))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz prop) p) (zz n))
 (iff (forall ((zz k)) (implies (apply-operator &lt;= n k) (apply-operator p k)))
  (and truth
   (forall ((zz m))
    (implies
     (and (apply-operator &lt;= n m)
      (forall ((zz k))
       (implies (and (apply-operator &lt;= n k) (apply-operator &lt; k m))
        (apply-operator p k))))
     (apply-operator p m))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="prop"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="k"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="k"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="p"/>
        <om:OMV name="k"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMS cd="the-kernel-theory" name="truth"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="m"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="and"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="n"/>
          <om:OMV name="m"/>
         </om:OMA>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="forall"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="k"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="implies"/>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="and"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="k"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
             <om:OMV name="k"/>
             <om:OMV name="m"/>
            </om:OMA>
           </om:OMA>
           <om:OMA>
            <om:OMV name="p"/>
            <om:OMV name="k"/>
           </om:OMA>
          </om:OMA>
         </om:OMBIND>
        </om:OMA>
        <om:OMA>
         <om:OMV name="p"/>
         <om:OMV name="m"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="well-ordering-for-integers"  type="theorem">
<CMP>
 Theorem name: "well-ordering-for-integers". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,prop],
  nonvacuous_q{s}
   and 
  forsome(n:zz,forall(m:zz,m&lt;=n implies not(s(m))))
   implies 
  forsome(u:zz,s(u) and forall(v:zz,v&lt;u implies not(s(v)))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz prop) s))
 (implies
  (and (nonvacuous? s)
   (forsome ((zz n))
    (forall ((zz m))
     (implies (apply-operator &lt;= m n) (not (apply-operator s m))))))
  (forsome ((zz u))
   (and (apply-operator s u)
    (forall ((zz v))
     (implies (apply-operator &lt; v u) (not (apply-operator s v))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="prop"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="nonvacuous?"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="m"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="m"/>
          <om:OMV name="n"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="not"/>
          <om:OMA>
           <om:OMV name="s"/>
           <om:OMV name="m"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="u"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="u"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="v"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
          <om:OMV name="v"/>
          <om:OMV name="u"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="not"/>
          <om:OMA>
           <om:OMV name="s"/>
           <om:OMV name="v"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="set%min" kind="object">
<CMP> "set%min" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="set%min-def"  for="set%min"  type="simple">
<CMP>
 Symbol name: "set%min". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[zz],
  iota(k:zz,
    k in s and forall(j:zz,j&lt;k implies not(j in s))))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz unit%sort) s))
 (iota ((zz k))
  (and (i-in k s)
   (forall ((zz j)) (implies (apply-operator &lt; j k) (not (i-in j s)))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="k"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="k"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="j"/>
         <om:OMV name="k"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="not"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="i-in"/>
          <om:OMV name="j"/>
          <om:OMV name="s"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="iota-free-characterization-of-set%min"  type="theorem">
<CMP>
 Theorem name: "iota-free-characterization-of-set%min". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[zz],k:zz,
  set%min(s)=k
   iff 
  (k in s and forall(j:zz,j&lt;k implies not(j in s))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz unit%sort) s) (zz k))
 (iff (= (apply-operator set%min s) k)
  (and (i-in k s)
   (forall ((zz j)) (implies (apply-operator &lt; j k) (not (i-in j s)))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="k"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="set%min"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="k"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="k"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="j"/>
         <om:OMV name="k"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="not"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="i-in"/>
          <om:OMV name="j"/>
          <om:OMV name="s"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="definedness-of-set%min"  type="theorem">
<CMP>
 Theorem name: "definedness-of-set%min". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[zz],
  #(set%min(s))
   iff 
  (nonempty_indic_q{s}
   and 
  forsome(k:zz,forall(j:zz,j&lt;=k implies not(j in s)))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz unit%sort) s))
 (iff (is-defined (apply-operator set%min s))
  (and (i-nonempty-indicator? s)
   (forsome ((zz k))
    (forall ((zz j)) (implies (apply-operator &lt;= j k) (not (i-in j s))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="set%min"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-nonempty-indicator?"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="k"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="j"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="j"/>
          <om:OMV name="k"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="not"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="i-in"/>
           <om:OMV name="j"/>
           <om:OMV name="s"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="well-ordering-for-natural-numbers"  type="theorem">
<CMP>
 Theorem name: "well-ordering-for-natural-numbers". <with style="linebreak"/>

 Formula (string): 
"forall(s:[nn,prop],
  nonvacuous_q{s}
   implies 
  forsome(u:nn,s(u) and forall(v:nn,v&lt;u implies not(s(v)))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((nn prop) s))
 (implies (nonvacuous? s)
  (forsome ((nn u))
   (and (apply-operator s u)
    (forall ((nn v))
     (implies (apply-operator &lt; v u) (not (apply-operator s v))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="nn"/>
         <om:OMS cd="the-kernel-theory" name="prop"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="nonvacuous?"/>
      <om:OMV name="s"/>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="nn"/>
        </om:OMATP>
        <om:OMV name="u"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="u"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="nn"/>
          </om:OMATP>
          <om:OMV name="v"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
          <om:OMV name="v"/>
          <om:OMV name="u"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="not"/>
          <om:OMA>
           <om:OMV name="s"/>
           <om:OMV name="v"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="floor" kind="object">
<CMP> "floor" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="floor-def"  for="floor"  type="simple">
<CMP>
 Symbol name: "floor". <with style="linebreak"/>

 String defining expression: "lambda(x:rr,iota(z:zz,z&lt;=x and x&lt;1+z))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr x))
 (iota ((zz z))
  (and (apply-operator &lt;= z x) (apply-operator &lt; x (apply-operator + 1 z)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="z"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="z"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="x"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="+"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMV name="z"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="floor-definedness"  type="theorem">
<CMP>
 Theorem name: "floor-definedness". <with style="linebreak"/>

 Formula (string): "total_q{floor,[rr,zz]}". <with style="linebreak"/>

 Formula (s-expression): "(total? floor (undefined (rr zz)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "d-r-convergence". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="total?"/>
    <om:OMS cd="generic-theory-2" name="floor"/>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="undefined"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
     </om:OMA>
    </om:OMA>

   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="floor-characterization"  type="theorem">
<CMP>
 Theorem name: "floor-characterization". <with style="linebreak"/>

 Formula (string): "forall(x:rr,n:zz,floor(x)=n iff (n&lt;=x and x&lt;n+1))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x) (zz n))
 (iff (= (apply-operator floor x) n)
  (and (apply-operator &lt;= n x) (apply-operator &lt; x (apply-operator + n 1)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="n"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="n"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="x"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="+"/>
        <om:OMV name="n"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="floor-below-arg"  type="theorem">
<CMP>
 Theorem name: "floor-below-arg". <with style="linebreak"/>

 Formula (string): "forall(x:rr,floor(x)&lt;=x)". <with style="linebreak"/>

 Formula (s-expression): "(forall ((rr x)) (apply-operator &lt;= (apply-operator floor x) x))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="floor"/>
      <om:OMV name="x"/>
     </om:OMA>
     <om:OMV name="x"/>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="floor-plus-1-exceeds-arg"  type="theorem">
<CMP>
 Theorem name: "floor-plus-1-exceeds-arg". <with style="linebreak"/>

 Formula (string): "forall(x:rr,x&lt;1+floor(x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x))
 (apply-operator &lt; x (apply-operator + 1 (apply-operator floor x))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
     <om:OMV name="x"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="+"/>
      <om:OMS cd="h-o-real-arithmetic" name="1"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="floor-not-much-below-arg"  type="theorem">
<CMP>
 Theorem name: "floor-not-much-below-arg". <with style="linebreak"/>

 Formula (string): "forall(x:rr,n:zz,n&lt;=x implies n&lt;=floor(x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x) (zz n))
 (implies (apply-operator &lt;= n x)
  (apply-operator &lt;= n (apply-operator floor x))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMV name="n"/>
      <om:OMV name="x"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMV name="n"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="floor-inequality-characterization"  type="theorem">
<CMP>
 Theorem name: "floor-inequality-characterization". <with style="linebreak"/>

 Formula (string): "forall(x,y:rr,floor(x)&lt;=floor(y) iff floor(x)&lt;=y)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y))
 (iff (apply-operator &lt;= (apply-operator floor x) (apply-operator floor y))
  (apply-operator &lt;= (apply-operator floor x) y)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="y"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="monotonicity-of-floor"  type="theorem">
<CMP>
 Theorem name: "monotonicity-of-floor". <with style="linebreak"/>

 Formula (string): "forall(x,y:rr,x&lt;=y implies floor(x)&lt;=floor(y))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y))
 (implies (apply-operator &lt;= x y)
  (apply-operator &lt;= (apply-operator floor x) (apply-operator floor y))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMV name="x"/>
      <om:OMV name="y"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="integer-exponentiation-definedness"  type="theorem">
<CMP>
 Theorem name: "integer-exponentiation-definedness". <with style="linebreak"/>

 Formula (string): "forall(m,n:zz,1&lt;=n implies #(m^n,zz))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz m n))
 (implies (apply-operator &lt;= 1 n)
  (is-defined-in-sort (apply-operator ^ m n) zz)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="m"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMS cd="h-o-real-arithmetic" name="1"/>
      <om:OMV name="n"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="^"/>
       <om:OMV name="m"/>
       <om:OMV name="n"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="zz"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="integer-exponentiation-definedness-dr"  type="theorem">
<CMP>
 Theorem name: "integer-exponentiation-definedness-dr". <with style="linebreak"/>

 Formula (string): 
"forall(m,n:ind,
  #(m,zz) and #(n,zz) and 1&lt;=n implies #(m^n,zz))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((ind m n))
 (implies
  (and (is-defined-in-sort m zz) (is-defined-in-sort n zz)
   (apply-operator &lt;= 1 n))
  (is-defined-in-sort (apply-operator ^ m n) zz)))". <with style="linebreak"/>

 Usage list: "elementary-macete", "d-r-convergence". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="the-kernel-theory" name="ind"/>
      </om:OMATP>
      <om:OMV name="m"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="the-kernel-theory" name="ind"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
       <om:OMV name="m"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
       <om:OMV name="n"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="n"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="^"/>
       <om:OMV name="m"/>
       <om:OMV name="n"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="zz"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="product-power-is-iterated-power"  type="theorem">
<CMP>
 Theorem name: "product-power-is-iterated-power". <with style="linebreak"/>

 Formula (string): "forall(z:rr,n,m:zz,1&lt;=n and 1&lt;=m implies z^(n*m)==(z^n)^m)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr z) (zz n m))
 (implies (and (apply-operator &lt;= 1 n) (apply-operator &lt;= 1 m))
  (== (apply-operator ^ z (apply-operator * n m))
   (apply-operator ^ (apply-operator ^ z n) m))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="z"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="m"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="n"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="m"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="=="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="^"/>
       <om:OMV name="z"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="n"/>
        <om:OMV name="m"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="^"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="^"/>
        <om:OMV name="z"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMV name="m"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="mod" kind="object">
<CMP> "mod" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="mod-def"  for="mod"  type="simple">
<CMP>
 Symbol name: "mod". <with style="linebreak"/>

 String defining expression: "lambda(a,b:rr,a-b*floor(a/b))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr a b))
 (apply-operator sub a
  (apply-operator * b (apply-operator floor (apply-operator / a b)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="h-o-real-arithmetic" name="sub"/>
     <om:OMV name="a"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="*"/>
      <om:OMV name="b"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="floor"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="/"/>
        <om:OMV name="a"/>
        <om:OMV name="b"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="mod-of-negative"  type="theorem">
<CMP>
 Theorem name: "mod-of-negative". <with style="linebreak"/>

 Formula (string): "forall(a,b:rr,-b mod -a==-(b mod a))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a b))
 (== (apply-operator mod (apply-operator - b) (apply-operator - a))
  (apply-operator - (apply-operator mod b a))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="=="/>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="mod"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="-"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="-"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="-"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="mod"/>
       <om:OMV name="b"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="div" kind="object">
<CMP> "div" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="div-def"  for="div"  type="simple">
<CMP>
 Symbol name: "div". <with style="linebreak"/>

 String defining expression: "lambda(x,y:rr,floor(x/y))". <with style="linebreak"/>

 Defining s-expression: "(lambda ((rr x y)) (apply-operator floor (apply-operator / x y)))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="generic-theory-2" name="floor"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="/"/>
      <om:OMV name="x"/>
      <om:OMV name="y"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="mod-of-integer-is-integer"  type="theorem">
<CMP>
 Theorem name: "mod-of-integer-is-integer". <with style="linebreak"/>

 Formula (string): "forall(a,b:zz,not(b=0) implies #(a mod b,zz))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz a b))
 (implies (not (= b 0)) (is-defined-in-sort (apply-operator mod a b) zz)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="not"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="="/>
       <om:OMV name="b"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="mod"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="zz"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="positivity-of-rr-distance"  type="theorem">
<CMP>
 Theorem name: "positivity-of-rr-distance". <with style="linebreak"/>

 Formula (string): "forall(x,y:rr,0&lt;=lambda(x,y:rr,abs(x-y))(x,y))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y))
 (apply-operator &lt;= 0
  (apply-operator
   (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) x y)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
     <om:OMS cd="h-o-real-arithmetic" name="0"/>
     <om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="abs"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
      <om:OMV name="x"/>
      <om:OMV name="y"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="point-separation-for-rr-distance"  type="theorem">
<CMP>
 Theorem name: "point-separation-for-rr-distance". <with style="linebreak"/>

 Formula (string): "forall(x,y:rr,x=y iff lambda(x,y:rr,abs(x-y))(x,y)=0)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y))
 (iff (= x y)
  (=
   (apply-operator
    (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) x y)
   0)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMV name="x"/>
      <om:OMV name="y"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="x"/>
         </om:OMATTR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="y"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="abs"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMV name="x"/>
          <om:OMV name="y"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="symmetry-of-rr-distance"  type="theorem">
<CMP>
 Theorem name: "symmetry-of-rr-distance". <with style="linebreak"/>

 Formula (string): 
"forall(x,y:rr,
  lambda(x,y:rr,abs(x-y))(x,y)=lambda(x,y:rr,abs(x-y))(y,x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y))
 (=
  (apply-operator
   (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) x y)
  (apply-operator
   (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) y x)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="abs"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
      <om:OMV name="x"/>
      <om:OMV name="y"/>
     </om:OMA>
     <om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="abs"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
      <om:OMV name="y"/>
      <om:OMV name="x"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="triangle-inequality-for-rr-distance"  type="theorem">
<CMP>
 Theorem name: "triangle-inequality-for-rr-distance". <with style="linebreak"/>

 Formula (string): 
"forall(x,y,z:rr,
  lambda(x,y:rr,abs(x-y))(x,z)
  &lt;=lambda(x,y:rr,abs(x-y))(x,y)
    +lambda(x,y:rr,abs(x-y))(y,z))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y z))
 (apply-operator &lt;=
  (apply-operator
   (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) x z)
  (apply-operator +
   (apply-operator
    (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) x y)
   (apply-operator
    (lambda ((rr x y)) (apply-operator abs (apply-operator sub x y))) y z))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="z"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
     <om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="abs"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
      <om:OMV name="x"/>
      <om:OMV name="z"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="+"/>
      <om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="x"/>
         </om:OMATTR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="y"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="abs"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMV name="x"/>
          <om:OMV name="y"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
      <om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="x"/>
         </om:OMATTR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="y"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="abs"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMV name="x"/>
          <om:OMV name="y"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
       <om:OMV name="y"/>
       <om:OMV name="z"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sub-is-diff"  type="theorem">
<CMP>
 Theorem name: "sub-is-diff". <with style="linebreak"/>

 Formula (string): "sub=lambda(x,y:rr,-y+x)". <with style="linebreak"/>

 Formula (s-expression): "(= sub (lambda ((rr x y)) (apply-operator + (apply-operator - y) x)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="="/>
    <om:OMS cd="h-o-real-arithmetic" name="sub"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="+"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="-"/>
       <om:OMV name="y"/>
      </om:OMA>
      <om:OMV name="x"/>
     </om:OMA>
    </om:OMBIND>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="non-empty-range"  type="theorem">
<CMP>
 Theorem name: "non-empty-range". <with style="linebreak"/>

 Formula (string): 
"forall(s:[ind_1,ind_2],
  nonempty_indic_q{ran{s}} iff forsome(x:ind_1,#(s(x))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_2) s))
 (iff (i-nonempty-indicator? (m-range s))
  (forsome ((ind_1 x)) (is-defined (apply-operator s x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-nonempty-indicator?"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sort-definedness-formula-for-majorizes_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-majorizes_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): "#(lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies x&lt;=y)),[rr,sets[rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda ((rr y) ((rr unit%sort) s))
  (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= x y))))
 (rr (rr unit%sort) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="x"/>
        <om:OMV name="y"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="majorizes" kind="object">
<CMP> "majorizes" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="majorizes-def"  for="majorizes"  type="simple">
<CMP>
 Symbol name: "majorizes". <with style="linebreak"/>

 String defining expression: "lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies x&lt;=y))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr y) ((rr unit%sort) s))
 (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= x y))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-sup_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-sup_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:sets[rr],
    iota(y:rr,
      y majorizes s
       and 
      forall(z:rr,z majorizes s implies y&lt;=z))),[sets[rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((rr unit%sort) s))
  (iota ((rr y))
   (and (apply-operator majorizes y s)
    (forall ((rr z))
     (implies (apply-operator majorizes z s) (apply-operator &lt;= y z))))))
 ((rr unit%sort) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="iota"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="majorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="z"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="generic-theory-2" name="majorizes"/>
          <om:OMV name="z"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="y"/>
          <om:OMV name="z"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="sup" kind="object">
<CMP> "sup" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="sup-def"  for="sup"  type="simple">
<CMP>
 Symbol name: "sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  iota(y:rr,
    y majorizes s
     and 
    forall(z:rr,z majorizes s implies y&lt;=z)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (iota ((rr y))
  (and (apply-operator majorizes y s)
   (forall ((rr z))
    (implies (apply-operator majorizes z s) (apply-operator &lt;= y z))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="majorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="generic-theory-2" name="majorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="y"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-nondecreasing_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-nondecreasing_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    forall(n,p:zz,
      n&lt;=p and #(s(n)) and #(s(p)) implies s(n)&lt;=s(p))),[[zz,rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (forall ((zz n p))
   (implies
    (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
     (is-defined (apply-operator s p)))
    (apply-operator &lt;= (apply-operator s n) (apply-operator s p)))))
 ((zz rr) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="p"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="nondecreasing" kind="object">
<CMP> "nondecreasing" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="nondecreasing-def"  for="nondecreasing"  type="simple">
<CMP>
 Symbol name: "nondecreasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies s(n)&lt;=s(p)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator &lt;= (apply-operator s n) (apply-operator s p)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-minorizes_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-minorizes_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): "#(lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies y&lt;=x)),[rr,sets[rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda ((rr y) ((rr unit%sort) s))
  (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= y x))))
 (rr (rr unit%sort) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="y"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="minorizes" kind="object">
<CMP> "minorizes" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="minorizes-def"  for="minorizes"  type="simple">
<CMP>
 Symbol name: "minorizes". <with style="linebreak"/>

 String defining expression: "lambda(y:rr,s:sets[rr],forall(x:rr,x in s implies y&lt;=x))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda ((rr y) ((rr unit%sort) s))
 (forall ((rr x)) (implies (i-in x s) (apply-operator &lt;= y x))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="x"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-in"/>
       <om:OMV name="x"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="y"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-inf_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-inf_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:sets[rr],
    iota(y:rr,
      y minorizes s
       and 
      forall(z:rr,z minorizes s implies z&lt;=y))),[sets[rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((rr unit%sort) s))
  (iota ((rr y))
   (and (apply-operator minorizes y s)
    (forall ((rr z))
     (implies (apply-operator minorizes z s) (apply-operator &lt;= z y))))))
 ((rr unit%sort) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          <om:OMS cd="the-kernel-theory" name="unit%sort"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="iota"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="minorizes"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="z"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="generic-theory-2" name="minorizes"/>
          <om:OMV name="z"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="z"/>
          <om:OMV name="y"/>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        <om:OMS cd="the-kernel-theory" name="unit%sort"/>
      </om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="rr"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="inf" kind="object">
<CMP> "inf" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="inf-def"  for="inf"  type="simple">
<CMP>
 Symbol name: "inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  iota(y:rr,
    y minorizes s
     and 
    forall(z:rr,z minorizes s implies z&lt;=y)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (iota ((rr y))
  (and (apply-operator minorizes y s)
   (forall ((rr z))
    (implies (apply-operator minorizes z s) (apply-operator &lt;= z y))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="iota"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="y"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="minorizes"/>
       <om:OMV name="y"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="z"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="generic-theory-2" name="minorizes"/>
         <om:OMV name="z"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="z"/>
         <om:OMV name="y"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-nonincreasing_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-nonincreasing_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    forall(n,p:zz,
      n&lt;=p and #(s(n)) and #(s(p)) implies s(p)&lt;=s(n))),[[zz,rr],prop])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (forall ((zz n p))
   (implies
    (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
     (is-defined (apply-operator s p)))
    (apply-operator &lt;= (apply-operator s p) (apply-operator s n)))))
 ((zz rr) prop))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="n"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="p"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="funsort"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="funsort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMA>
      <om:OMS cd="the-kernel-theory" name="prop"/>
    </om:OMA>
   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="nonincreasing" kind="object">
<CMP> "nonincreasing" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="nonincreasing-def"  for="nonincreasing"  type="simple">
<CMP>
 Symbol name: "nonincreasing". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forall(n,p:zz,
    n&lt;=p and #(s(n)) and #(s(p)) implies s(p)&lt;=s(n)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forall ((zz n p))
  (implies
   (and (apply-operator &lt;= n p) (is-defined (apply-operator s n))
    (is-defined (apply-operator s p)))
   (apply-operator &lt;= (apply-operator s p) (apply-operator s n)))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forall"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="n"/>
      </om:OMATTR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="p"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="implies"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="n"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="is-defined"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="p"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="p"/>
       </om:OMA>
       <om:OMA>
        <om:OMV name="s"/>
        <om:OMV name="n"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-lim%inf_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-lim%inf_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    sup(ran{lambda(n:zz,
              inf(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))})),[[zz,rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (apply-operator sup
   (m-range
    (lambda ((zz n))
     (apply-operator inf
      (m-range
       (lambda ((zz m))
        (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))
 ((zz rr) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="generic-theory-2" name="sup"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="generic-theory-2" name="inf"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-range"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="m"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="s"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="undefined"/>
             <om:OMS cd="h-o-real-arithmetic" name="rr"/>
             </om:OMA>

            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="lim%inf" kind="object">
<CMP> "lim%inf" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="lim%inf-def"  for="lim%inf"  type="simple">
<CMP>
 Symbol name: "lim%inf". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  sup(ran{lambda(n:zz,
            inf(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (apply-operator sup
  (m-range
   (lambda ((zz n))
    (apply-operator inf
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="generic-theory-2" name="sup"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="generic-theory-2" name="inf"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="h-o-real-arithmetic" name="rr"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sort-definedness-formula-for-lim%sup_h-o-real-arithmetic"  type="theorem">
<CMP>
 Theorem name: "sort-definedness-formula-for-lim%sup_h-o-real-arithmetic". <with style="linebreak"/>

 Formula (string): 
"#(lambda(s:[zz,rr],
    inf(ran{lambda(n:zz,
              sup(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))})),[[zz,rr],rr])". <with style="linebreak"/>

 Formula (s-expression): 
"(is-defined-in-sort
 (lambda (((zz rr) s))
  (apply-operator inf
   (m-range
    (lambda ((zz n))
     (apply-operator sup
      (m-range
       (lambda ((zz m))
        (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))
 ((zz rr) rr))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="is-defined-in-sort"/>
    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="lambda"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="s"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="generic-theory-2" name="inf"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="m-range"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="n"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="generic-theory-2" name="sup"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-range"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="m"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
             <om:OMV name="n"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="s"/>
             <om:OMV name="m"/>
            </om:OMA>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="undefined"/>
             <om:OMS cd="h-o-real-arithmetic" name="rr"/>
             </om:OMA>

            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="lim%sup" kind="object">
<CMP> "lim%sup" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="lim%sup-def"  for="lim%sup"  type="simple">
<CMP>
 Symbol name: "lim%sup". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  inf(ran{lambda(n:zz,
            sup(ran{lambda(m:zz,if(n&lt;=m, s(m), ?rr))}))}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (apply-operator inf
  (m-range
   (lambda ((zz n))
    (apply-operator sup
     (m-range
      (lambda ((zz m))
       (if (apply-operator &lt;= n m) (apply-operator s m) (undefined rr)))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="generic-theory-2" name="inf"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-range"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="m"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="n"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMV name="s"/>
            <om:OMV name="m"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="undefined"/>
            <om:OMS cd="h-o-real-arithmetic" name="rr"/>
            </om:OMA>

           </om:OMA>
          </om:OMBIND>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="sum-inequality-macete"  type="theorem">
<CMP>
 Theorem name: "sum-inequality-macete". <with style="linebreak"/>

 Formula (string): "forall(x,y,z,u:rr,x&lt;=z and y&lt;=u implies x+y&lt;=z+u)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr x y z u))
 (implies (and (apply-operator &lt;= x z) (apply-operator &lt;= y u))
  (apply-operator &lt;= (apply-operator + x y) (apply-operator + z u))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="y"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="z"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="u"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="x"/>
       <om:OMV name="z"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="y"/>
       <om:OMV name="u"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMV name="x"/>
       <om:OMV name="y"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMV name="z"/>
       <om:OMV name="u"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sup-sum"  type="theorem">
<CMP>
 Theorem name: "sup-sum". <with style="linebreak"/>

 Formula (string): 
"forall(f,g:[ind_1,rr],
  #(sup(ran{f}))
   and 
  #(sup(ran{g}))
   and 
  nonempty_indic_q{dom{f} inters dom{g}}
   implies 
  sup(ran{lambda(x:ind_1,f(x)+g(x))})
  &lt;=sup(ran{f})+sup(ran{g}))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 rr) f g))
 (implies
  (and (is-defined (apply-operator sup (m-range f)))
   (is-defined (apply-operator sup (m-range g)))
   (i-nonempty-indicator? (i-intersection (m-domain f) (m-domain g))))
  (apply-operator &lt;=
   (apply-operator sup
    (m-range
     (lambda ((ind_1 x))
      (apply-operator + (apply-operator f x) (apply-operator g x)))))
   (apply-operator + (apply-operator sup (m-range f))
    (apply-operator sup (m-range g))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="g"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="g"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-nonempty-indicator?"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-intersection"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-domain"/>
         <om:OMV name="f"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-domain"/>
         <om:OMV name="g"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="sup"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-range"/>
        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="lambda"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
           </om:OMATP>
           <om:OMV name="x"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMA>
           <om:OMV name="f"/>
           <om:OMV name="x"/>
          </om:OMA>
          <om:OMA>
           <om:OMV name="g"/>
           <om:OMV name="x"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="g"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sup-minus-epsilon"  type="theorem">
<CMP>
 Theorem name: "sup-minus-epsilon". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],eps:rr,
  0&lt;eps implies not(sup(s)-eps majorizes s))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr eps))
 (implies (apply-operator &lt; 0 eps)
  (not
   (apply-operator majorizes (apply-operator sub (apply-operator sup s) eps)
    s))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="eps"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
      <om:OMV name="eps"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="not"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="majorizes"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMA>
         <om:OMS cd="generic-theory-2" name="sup"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMV name="s"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sup-minus-epsilon-corollary"  type="theorem">
<CMP>
 Theorem name: "sup-minus-epsilon-corollary". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],eps:rr,
  0&lt;eps and #(sup(s))
   implies 
  forsome(x:rr,x in s and sup(s)-eps&lt;x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr eps))
 (implies (and (apply-operator &lt; 0 eps) (is-defined (apply-operator sup s)))
  (forsome ((rr x))
   (and (i-in x s)
    (apply-operator &lt; (apply-operator sub (apply-operator sup s) eps) x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="eps"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="eps"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="x"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="x"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMA>
          <om:OMS cd="generic-theory-2" name="sup"/>
          <om:OMV name="s"/>
         </om:OMA>
         <om:OMV name="eps"/>
        </om:OMA>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing-sequences-converge"  type="theorem">
<CMP>
 Theorem name: "nondecreasing-sequences-converge". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],
  nondecreasing(f)
   and 
  forsome(n:zz,forall(k:zz,n&lt;=k implies #(f(k))))
   and 
  #(sup(ran{f}))
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(k:zz,
      forall(j:zz,k&lt;=j implies sup(ran{f})-f(j)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f))
 (implies
  (and (apply-operator nondecreasing f)
   (forsome ((zz n))
    (forall ((zz k))
     (implies (apply-operator &lt;= n k) (is-defined (apply-operator f k)))))
   (is-defined (apply-operator sup (m-range f))))
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz k))
     (forall ((zz j))
      (implies (apply-operator &lt;= k j)
       (apply-operator &lt;=
        (apply-operator sub (apply-operator sup (m-range f))
         (apply-operator f j))
        eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="nondecreasing"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="n"/>
          <om:OMV name="k"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="f"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMV name="k"/>
           <om:OMV name="j"/>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sub"/>
            <om:OMA>
             <om:OMS cd="generic-theory-2" name="sup"/>
             <om:OMA>
              <om:OMS cd="the-kernel-theory" name="m-range"/>
              <om:OMV name="f"/>
             </om:OMA>
            </om:OMA>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j"/>
            </om:OMA>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing-sequences-converge-corollary"  type="theorem">
<CMP>
 Theorem name: "nondecreasing-sequences-converge-corollary". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],
  nondecreasing(f)
   and 
  forsome(n:zz,forall(k:zz,n&lt;=k implies #(f(k))))
   and 
  #(sup(ran{f}))
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(k:zz,
      forall(j,j_1:zz,
        k&lt;=j and j&lt;=j_1 implies f(j_1)-f(j)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f))
 (implies
  (and (apply-operator nondecreasing f)
   (forsome ((zz n))
    (forall ((zz k))
     (implies (apply-operator &lt;= n k) (is-defined (apply-operator f k)))))
   (is-defined (apply-operator sup (m-range f))))
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz k))
     (forall ((zz j j_1))
      (implies (and (apply-operator &lt;= k j) (apply-operator &lt;= j j_1))
       (apply-operator &lt;=
        (apply-operator sub (apply-operator f j_1) (apply-operator f j))
        eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="nondecreasing"/>
       <om:OMV name="f"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forsome"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="n"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="n"/>
          <om:OMV name="k"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="f"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMBIND>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="m-range"/>
         <om:OMV name="f"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j_1"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="and"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="k"/>
            <om:OMV name="j"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
           </om:OMA>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sub"/>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j_1"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="f"/>
             <om:OMV name="j"/>
            </om:OMA>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sum-interval-additivity"  type="theorem">
<CMP>
 Theorem name: "sum-interval-additivity". <with style="linebreak"/>

 Formula (string): 
"forall(m,n,p:zz,f:[zz,rr],
  m&lt;=n and n&lt;=p implies sum(m,n,f)+sum(n+1,p,f)==sum(m,p,f))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz m n p) ((zz rr) f))
 (implies (and (apply-operator &lt;= m n) (apply-operator &lt;= n p))
  (==
   (apply-operator + (apply-operator sum m n f)
    (apply-operator sum (apply-operator + n 1) p f))
   (apply-operator sum m p f))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="m"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="m"/>
       <om:OMV name="n"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="n"/>
       <om:OMV name="p"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="=="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="+"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMV name="m"/>
        <om:OMV name="n"/>
        <om:OMV name="f"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="+"/>
         <om:OMV name="n"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
        </om:OMA>
        <om:OMV name="p"/>
        <om:OMV name="f"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="m"/>
       <om:OMV name="p"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="sum-nonnegativity"  type="theorem">
<CMP>
 Theorem name: "sum-nonnegativity". <with style="linebreak"/>

 Formula (string): 
"forall(f:[zz,rr],a,b:zz,
  forall(z:zz,a&lt;=z and z&lt;=b implies 0&lt;=f(z))
   implies 
  0&lt;=sum(a,b,f))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) f) (zz a b))
 (implies
  (forall ((zz z))
   (implies (and (apply-operator &lt;= a z) (apply-operator &lt;= z b))
    (apply-operator &lt;= 0 (apply-operator f z))))
  (apply-operator &lt;= 0 (apply-operator sum a b f))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="b"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="z"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="a"/>
         <om:OMV name="z"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="z"/>
         <om:OMV name="b"/>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMA>
         <om:OMV name="f"/>
         <om:OMV name="z"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="a"/>
       <om:OMV name="b"/>
       <om:OMV name="f"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="nondecreasing%sums"  type="theorem">
<CMP>
 Theorem name: "nondecreasing%sums". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,rr],k:zz,
  forall(n:zz,k&lt;=n implies 0&lt;=s(n))
   implies 
  nondecreasing(lambda(p:zz,sum(k,p,s))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) s) (zz k))
 (implies
  (forall ((zz n))
   (implies (apply-operator &lt;= k n)
    (apply-operator &lt;= 0 (apply-operator s n))))
  (apply-operator nondecreasing (lambda ((zz p)) (apply-operator sum k p s)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="k"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="k"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMA>
         <om:OMV name="s"/>
         <om:OMV name="n"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="nondecreasing"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="p"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sum"/>
        <om:OMV name="k"/>
        <om:OMV name="p"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="summable%nonnegative" kind="object">
<CMP> "summable%nonnegative" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="summable%nonnegative-def"  for="summable%nonnegative"  type="simple">
<CMP>
 Symbol name: "summable%nonnegative". <with style="linebreak"/>

 String defining expression: 
"lambda(s:[zz,rr],
  forsome(k:zz,
    forall(n:zz,
      k&lt;=n
       implies 
      0&lt;=s(n) and #(sup(ran{lambda(p:zz,sum(k,p,s))})))))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((zz rr) s))
 (forsome ((zz k))
  (forall ((zz n))
   (implies (apply-operator &lt;= k n)
    (and (apply-operator &lt;= 0 (apply-operator s n))
     (is-defined
      (apply-operator sup
       (m-range (lambda ((zz p)) (apply-operator sum k p s))))))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="zz"/>
       </om:OMATP>
       <om:OMV name="k"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
        <om:OMV name="k"/>
        <om:OMV name="n"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMS cd="h-o-real-arithmetic" name="0"/>
         <om:OMA>
          <om:OMV name="s"/>
          <om:OMV name="n"/>
         </om:OMA>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="is-defined"/>
         <om:OMA>
          <om:OMS cd="generic-theory-2" name="sup"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="m-range"/>
           <om:OMBIND>
            <om:OMS cd="the-kernel-theory" name="lambda"/>
            <om:OMBVAR>

             <om:OMATTR>
              <om:OMATP>
               <om:OMS cd="the-kernel-theory" name="sort"/>
               <om:OMS cd="h-o-real-arithmetic" name="zz"/>
              </om:OMATP>
              <om:OMV name="p"/>
             </om:OMATTR>

            </om:OMBVAR>

            <om:OMA>
             <om:OMS cd="h-o-real-arithmetic" name="sum"/>
             <om:OMV name="k"/>
             <om:OMV name="p"/>
             <om:OMV name="s"/>
            </om:OMA>
           </om:OMBIND>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="small%tails%of%summable%nonnegative%sequence"  type="theorem">
<CMP>
 Theorem name: "small%tails%of%summable%nonnegative%sequence". <with style="linebreak"/>

 Formula (string): 
"forall(s:[zz,rr],
  summable%nonnegative(s)
   implies 
  forall(eps:rr,
    0&lt;eps
     implies 
    forsome(p:zz,
      forall(j,j_1:zz,
        p&lt;=j and j&lt;=j_1 implies sum(j,j_1,s)&lt;=eps))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz rr) s))
 (implies (apply-operator summable%nonnegative s)
  (forall ((rr eps))
   (implies (apply-operator &lt; 0 eps)
    (forsome ((zz p))
     (forall ((zz j j_1))
      (implies (and (apply-operator &lt;= p j) (apply-operator &lt;= j j_1))
       (apply-operator &lt;= (apply-operator sum j j_1 s) eps))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="summable%nonnegative"/>
      <om:OMV name="s"/>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="eps"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="implies"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="eps"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forsome"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="p"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMBIND>
         <om:OMS cd="the-kernel-theory" name="forall"/>
         <om:OMBVAR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j"/>
          </om:OMATTR>

          <om:OMATTR>
           <om:OMATP>
            <om:OMS cd="the-kernel-theory" name="sort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           </om:OMATP>
           <om:OMV name="j_1"/>
          </om:OMATTR>

         </om:OMBVAR>

         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="and"/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="p"/>
            <om:OMV name="j"/>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
           </om:OMA>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
           <om:OMA>
            <om:OMS cd="h-o-real-arithmetic" name="sum"/>
            <om:OMV name="j"/>
            <om:OMV name="j_1"/>
            <om:OMV name="s"/>
           </om:OMA>
           <om:OMV name="eps"/>
          </om:OMA>
         </om:OMA>
        </om:OMBIND>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="discrete%set" kind="object">
<CMP> "discrete%set" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="discrete%set-def"  for="discrete%set"  type="simple">
<CMP>
 Symbol name: "discrete%set". <with style="linebreak"/>

 String defining expression: 
"lambda(s:sets[rr],
  forsome(a:rr,0&lt;a and forall(x,y:rr,x&lt;y implies a&lt;=y-x)))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s))
 (forsome ((rr a))
  (and (apply-operator &lt; 0 a)
   (forall ((rr x y))
    (implies (apply-operator &lt; x y)
     (apply-operator &lt;= a (apply-operator sub y x)))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
       </om:OMATP>
       <om:OMV name="a"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="forall"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="y"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="implies"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="x"/>
         <om:OMV name="y"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
         <om:OMV name="a"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMV name="y"/>
          <om:OMV name="x"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="discrete-sets-contain-sup-lemma"  type="theorem">
<CMP>
 Theorem name: "discrete-sets-contain-sup-lemma". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],
  discrete%set(s) and #(sup(s))
   implies 
  forsome(a:rr,
    0&lt;a
     and 
    forall(x:rr,x in s implies x=sup(s) or x&lt;=sup(s)-a)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s))
 (implies
  (and (apply-operator discrete%set s) (is-defined (apply-operator sup s)))
  (forsome ((rr a))
   (and (apply-operator &lt; 0 a)
    (forall ((rr x))
     (or (implies (i-in x s) (= x (apply-operator sup s)))
      (apply-operator &lt;= x (apply-operator sub (apply-operator sup s) a))))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="a"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
        <om:OMV name="a"/>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="rr"/>
          </om:OMATP>
          <om:OMV name="x"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="or"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="implies"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="i-in"/>
           <om:OMV name="x"/>
           <om:OMV name="s"/>
          </om:OMA>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="="/>
           <om:OMV name="x"/>
           <om:OMA>
            <om:OMS cd="generic-theory-2" name="sup"/>
            <om:OMV name="s"/>
           </om:OMA>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
          <om:OMV name="x"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMA>
            <om:OMS cd="generic-theory-2" name="sup"/>
            <om:OMV name="s"/>
           </om:OMA>
           <om:OMV name="a"/>
          </om:OMA>
         </om:OMA>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="empty-indic-sup-is-undefined"  type="theorem">
<CMP>
 Theorem name: "empty-indic-sup-is-undefined". <with style="linebreak"/>

 Formula (string): "not(#(sup(empty_indic{rr})))". <with style="linebreak"/>

 Formula (s-expression): "(not (is-defined (apply-operator sup (i-empty-indicator (undefined rr)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="not"/>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="is-defined"/>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="sup"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="i-empty-indicator"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="undefined"/>
        <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMA>

       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="discrete-sets-contain-sup"  type="theorem">
<CMP>
 Theorem name: "discrete-sets-contain-sup". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],
  discrete%set(s) and #(sup(s)) implies sup(s) in s)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s))
 (implies
  (and (apply-operator discrete%set s) (is-defined (apply-operator sup s)))
  (i-in (apply-operator sup s) s)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="sup"/>
        <om:OMV name="s"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="sup"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="preceding" kind="object">
<CMP> "preceding" - defined constant in the theory "generic-theory-2". </CMP>
</symbol>

<definition xml:id="preceding-def"  for="preceding"  type="simple">
<CMP>
 Symbol name: "preceding". <with style="linebreak"/>

 String defining expression: "lambda(s:sets[rr],a:rr,sup(indic{x:rr,  x in s and x&lt;a}))". <with style="linebreak"/>

 Defining s-expression: 
"(lambda (((rr unit%sort) s) (rr a))
 (apply-operator sup
  (predicate-to-indicator
   (lambda ((rr x)) (and (i-in x s) (apply-operator &lt; x a))))))". <with style="linebreak"/>

 Usage list: none. <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="lambda"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="generic-theory-2" name="sup"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="predicate-to-indicator"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         </om:OMATP>
         <om:OMV name="x"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="i-in"/>
         <om:OMV name="x"/>
         <om:OMV name="s"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
         <om:OMV name="x"/>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="preceding-for-discrete-sets"  type="theorem">
<CMP>
 Theorem name: "preceding-for-discrete-sets". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],x:rr,
  discrete%set(s) and #(preceding(s,x))
   implies 
  preceding(s,x) in s)". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr x))
 (implies
  (and (apply-operator discrete%set s)
   (is-defined (apply-operator preceding s x)))
  (i-in (apply-operator preceding s x) s)))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="discrete%set"/>
       <om:OMV name="s"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="preceding"/>
        <om:OMV name="s"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="i-in"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="preceding"/>
       <om:OMV name="s"/>
       <om:OMV name="x"/>
      </om:OMA>
      <om:OMV name="s"/>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="preceding-defined"  type="theorem">
<CMP>
 Theorem name: "preceding-defined". <with style="linebreak"/>

 Formula (string): 
"forall(s:sets[rr],x:rr,
  #(preceding(s,x)) iff forsome(y:rr,y in s and y&lt;x))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((rr unit%sort) s) (rr x))
 (iff (is-defined (apply-operator preceding s x))
  (forsome ((rr y)) (and (i-in y s) (apply-operator &lt; y x)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="s"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="iff"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="preceding"/>
       <om:OMV name="s"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forsome"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="rr"/>
        </om:OMATP>
        <om:OMV name="y"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="i-in"/>
        <om:OMV name="y"/>
        <om:OMV name="s"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
        <om:OMV name="y"/>
        <om:OMV name="x"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-image-of-covers"  type="theorem">
<CMP>
 Theorem name: "inverse-image-of-covers". <with style="linebreak"/>

 Formula (string): 
"forall(v:[zz,sets[ind_2]],a:sets[ind_1],f:[ind_1,ind_2],
  total_q{f,[ind_1,ind_2]}
   implies 
  countable%cover{v,image{f,a}}
   iff 
  countable%cover{lambda(k:zz,
                    if(#(v(k)),
                      inv_image{f,v(k)},
                      ?sets[ind_1])),
                  a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz (ind_2 unit%sort)) v) ((ind_1 unit%sort) a) ((ind_1 ind_2) f))
 (implies (total? f (undefined (ind_1 ind_2)))
  (iff (countable%cover v (m-image f a))
   (countable%cover
    (lambda ((zz k))
     (if (is-defined (apply-operator v k))
      (m-inverse-image f (apply-operator v k)) (undefined (ind_1 unit%sort))))
    a))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="funsort"/>
           <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
           <om:OMS cd="the-kernel-theory" name="unit%sort"/>
         </om:OMA>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="v"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="iff"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="countable%cover"/>
       <om:OMV name="v"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-image"/>
        <om:OMV name="f"/>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="countable%cover"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="if"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="v"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
          <om:OMV name="f"/>
          <om:OMA>
           <om:OMV name="v"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="undefined"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="funsort"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            <om:OMS cd="the-kernel-theory" name="unit%sort"/>
          </om:OMA>
         </om:OMA>

        </om:OMA>
       </om:OMBIND>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="inverse-image-of-finite-covers"  type="theorem">
<CMP>
 Theorem name: "inverse-image-of-finite-covers". <with style="linebreak"/>

 Formula (string): 
"forall(v:[zz,sets[ind_2]],a:sets[ind_1],f:[ind_1,ind_2],
  total_q{f,[ind_1,ind_2]}
   implies 
  finite%cover{v,image{f,a}}
   iff 
  finite%cover{lambda(k:zz,
                 if(#(v(k)),
                   inv_image{f,v(k)},
                   ?sets[ind_1])),
               a})". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((zz (ind_2 unit%sort)) v) ((ind_1 unit%sort) a) ((ind_1 ind_2) f))
 (implies (total? f (undefined (ind_1 ind_2)))
  (iff (finite%cover v (m-image f a))
   (finite%cover
    (lambda ((zz k))
     (if (is-defined (apply-operator v k))
      (m-inverse-image f (apply-operator v k)) (undefined (ind_1 unit%sort))))
    a))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="funsort"/>
           <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
           <om:OMS cd="the-kernel-theory" name="unit%sort"/>
         </om:OMA>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="v"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="the-kernel-theory" name="unit%sort"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="total?"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="undefined"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-2" name="ind_2"/>
       </om:OMA>
      </om:OMA>

     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="iff"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="finite%cover"/>
       <om:OMV name="v"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="m-image"/>
        <om:OMV name="f"/>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="finite%cover"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="k"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="if"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="is-defined"/>
          <om:OMA>
           <om:OMV name="v"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="m-inverse-image"/>
          <om:OMV name="f"/>
          <om:OMA>
           <om:OMV name="v"/>
           <om:OMV name="k"/>
          </om:OMA>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="undefined"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="funsort"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            <om:OMS cd="the-kernel-theory" name="unit%sort"/>
          </om:OMA>
         </om:OMA>

        </om:OMA>
       </om:OMBIND>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>

<symbol xml:id="iterate" kind="object">
<CMP> "iterate" - recursively defined constant in the theory "generic-theory-2".</CMP>
</symbol>

<definition xml:id="iterate-def"  for="iterate"  type="simple">
<CMP>
This defines the recursive constant "iterate".

<with style="linebreak"/>
"iota(f_0:[[ind_1,ind_1],ind_1,[zz,ind_1]],
  forsome(g_0:[[ind_1,ind_1],ind_1,[zz,ind_1]],
    forall(f_p:[ind_1,ind_1],x_p:ind_1,
      (total_q{g_0,[[ind_1,ind_1],ind_1,[zz,ind_1]]}
       and 
      g_0(f_p,x_p)
      =lambda(n:zz,if(n=0, x_p, f_p(g_0(f_p,x_p)(n-1)))))
       and 
      forall(h_0:[zz,ind_1],
        h_0=lambda(n:zz,if(n=0, x_p, f_p(h_0(n-1))))
         implies 
        forall(u_0:zz,
          #(g_0(f_p,x_p)(u_0))
           implies 
          g_0(f_p,x_p)(u_0)=h_0(u_0)))
       and 
      f_0=g_0)))" <with style="linebreak"/>

is defined as the least fixed point of the following functional:
<with style="linebreak"/>

 
"lambda(iter:[zz,ind_1],f:[ind_1,ind_1],x:ind_1,
  lambda(n:zz,if(n=0, x, f(iter(n-1)))))".
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="iota"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="funsort"/>
           <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
           <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         </om:OMA>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="funsort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
           <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         </om:OMA>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f_0"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMBIND>
     <om:OMS cd="the-kernel-theory" name="forsome"/>
     <om:OMBVAR>

      <om:OMATTR>
       <om:OMATP>
        <om:OMS cd="the-kernel-theory" name="sort"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="funsort"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
          </om:OMA>
          <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="funsort"/>
            <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
          </om:OMA>
        </om:OMA>
       </om:OMATP>
       <om:OMV name="g_0"/>
      </om:OMATTR>

     </om:OMBVAR>

     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="forall"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="funsort"/>
           <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
           <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         </om:OMA>
        </om:OMATP>
        <om:OMV name="f_p"/>
       </om:OMATTR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMATP>
        <om:OMV name="x_p"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="and"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="and"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="total?"/>
         <om:OMV name="g_0"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="undefined"/>
          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="funsort"/>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="funsort"/>
              <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
              <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            </om:OMA>
            <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="funsort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
              <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
            </om:OMA>
          </om:OMA>
         </om:OMA>

        </om:OMA>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="="/>
         <om:OMA>
          <om:OMV name="g_0"/>
          <om:OMV name="f_p"/>
          <om:OMV name="x_p"/>
         </om:OMA>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="lambda"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="n"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="if"/>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="="/>
            <om:OMV name="n"/>
            <om:OMS cd="h-o-real-arithmetic" name="0"/>
           </om:OMA>
           <om:OMV name="x_p"/>
           <om:OMA>
            <om:OMV name="f_p"/>
            <om:OMA>
             <om:OMA>
              <om:OMV name="g_0"/>
              <om:OMV name="f_p"/>
              <om:OMV name="x_p"/>
             </om:OMA>
             <om:OMA>
              <om:OMS cd="h-o-real-arithmetic" name="sub"/>
              <om:OMV name="n"/>
              <om:OMS cd="h-o-real-arithmetic" name="1"/>
             </om:OMA>
            </om:OMA>
           </om:OMA>
          </om:OMA>
         </om:OMBIND>
        </om:OMA>
       </om:OMA>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="forall"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="funsort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
           </om:OMA>
          </om:OMATP>
          <om:OMV name="h_0"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="implies"/>
         <om:OMA>
          <om:OMS cd="the-kernel-theory" name="="/>
          <om:OMV name="h_0"/>
          <om:OMBIND>
           <om:OMS cd="the-kernel-theory" name="lambda"/>
           <om:OMBVAR>

            <om:OMATTR>
             <om:OMATP>
              <om:OMS cd="the-kernel-theory" name="sort"/>
              <om:OMS cd="h-o-real-arithmetic" name="zz"/>
             </om:OMATP>
             <om:OMV name="n"/>
            </om:OMATTR>

           </om:OMBVAR>

           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="if"/>
            <om:OMA>
             <om:OMS cd="the-kernel-theory" name="="/>
             <om:OMV name="n"/>
             <om:OMS cd="h-o-real-arithmetic" name="0"/>
            </om:OMA>
            <om:OMV name="x_p"/>
            <om:OMA>
             <om:OMV name="f_p"/>
             <om:OMA>
              <om:OMV name="h_0"/>
              <om:OMA>
               <om:OMS cd="h-o-real-arithmetic" name="sub"/>
               <om:OMV name="n"/>
               <om:OMS cd="h-o-real-arithmetic" name="1"/>
              </om:OMA>
             </om:OMA>
            </om:OMA>
           </om:OMA>
          </om:OMBIND>
         </om:OMA>
         <om:OMBIND>
          <om:OMS cd="the-kernel-theory" name="forall"/>
          <om:OMBVAR>

           <om:OMATTR>
            <om:OMATP>
             <om:OMS cd="the-kernel-theory" name="sort"/>
             <om:OMS cd="h-o-real-arithmetic" name="zz"/>
            </om:OMATP>
            <om:OMV name="u_0"/>
           </om:OMATTR>

          </om:OMBVAR>

          <om:OMA>
           <om:OMS cd="the-kernel-theory" name="implies"/>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="is-defined"/>
            <om:OMA>
             <om:OMA>
              <om:OMV name="g_0"/>
              <om:OMV name="f_p"/>
              <om:OMV name="x_p"/>
             </om:OMA>
             <om:OMV name="u_0"/>
            </om:OMA>
           </om:OMA>
           <om:OMA>
            <om:OMS cd="the-kernel-theory" name="="/>
            <om:OMA>
             <om:OMA>
              <om:OMV name="g_0"/>
              <om:OMV name="f_p"/>
              <om:OMV name="x_p"/>
             </om:OMA>
             <om:OMV name="u_0"/>
            </om:OMA>
            <om:OMA>
             <om:OMV name="h_0"/>
             <om:OMV name="u_0"/>
            </om:OMA>
           </om:OMA>
          </om:OMA>
         </om:OMBIND>
        </om:OMA>
       </om:OMBIND>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="f_0"/>
        <om:OMV name="g_0"/>
       </om:OMA>
      </om:OMA>
     </om:OMBIND>
    </om:OMBIND>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</definition>



<assertion xml:id="iterate-definedness"  type="theorem">
<CMP>
 Theorem name: "iterate-definedness". <with style="linebreak"/>

 Formula (string): 
"forall(f:[ind_1,ind_1],x:ind_1,z:zz,
  total_q{f,[ind_1,ind_1]} and 0&lt;=z
   implies 
  #(iterate(f,x)(z)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall (((ind_1 ind_1) f) (ind_1 x) (zz z))
 (implies (and (total? f (undefined (ind_1 ind_1))) (apply-operator &lt;= 0 z))
  (is-defined (apply-operator (apply-operator iterate f x) z))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="z"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="total?"/>
       <om:OMV name="f"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="undefined"/>
        <om:OMA>
         <om:OMS cd="the-kernel-theory" name="funsort"/>
          <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
          <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMA>
       </om:OMA>

      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="z"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="is-defined"/>
      <om:OMA>
       <om:OMA>
        <om:OMS cd="generic-theory-2" name="iterate"/>
        <om:OMV name="f"/>
        <om:OMV name="x"/>
       </om:OMA>
       <om:OMV name="z"/>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="undefined-for-negative"  type="theorem">
<CMP>
 Theorem name: "undefined-for-negative". <with style="linebreak"/>

 Formula (string): 
"forall(n:zz,x:ind_1,f:[ind_1,ind_1],
  n&lt;0 implies not(#(iterate(f,x)(n))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz n) (ind_1 x) ((ind_1 ind_1) f))
 (implies (apply-operator &lt; n 0)
  (not (is-defined (apply-operator (apply-operator iterate f x) n)))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
      <om:OMV name="n"/>
      <om:OMS cd="h-o-real-arithmetic" name="0"/>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="not"/>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="is-defined"/>
       <om:OMA>
        <om:OMA>
         <om:OMS cd="generic-theory-2" name="iterate"/>
         <om:OMV name="f"/>
         <om:OMV name="x"/>
        </om:OMA>
        <om:OMV name="n"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="iterate-translate"  type="theorem">
<CMP>
 Theorem name: "iterate-translate". <with style="linebreak"/>

 Formula (string): 
"forall(n:zz,x:ind_1,f:[ind_1,ind_1],
  f oo (iterate(f,x))
  =lambda(n:zz,if(n=[-1], ?ind_1, iterate(f,x)(n+1))))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((zz n) (ind_1 x) ((ind_1 ind_1) f))
 (= (m-composition f (apply-operator iterate f x))
  (lambda ((zz n))
   (if (= n -1) (undefined ind_1)
    (apply-operator (apply-operator iterate f x) (apply-operator + n 1))))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="n"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
      </om:OMATP>
      <om:OMV name="x"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       </om:OMA>
      </om:OMATP>
      <om:OMV name="f"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="="/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="m-composition"/>
      <om:OMV name="f"/>
      <om:OMA>
       <om:OMS cd="generic-theory-2" name="iterate"/>
       <om:OMV name="f"/>
       <om:OMV name="x"/>
      </om:OMA>
     </om:OMA>
     <om:OMBIND>
      <om:OMS cd="the-kernel-theory" name="lambda"/>
      <om:OMBVAR>

       <om:OMATTR>
        <om:OMATP>
         <om:OMS cd="the-kernel-theory" name="sort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
        </om:OMATP>
        <om:OMV name="n"/>
       </om:OMATTR>

      </om:OMBVAR>

      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="if"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="n"/>
        <om:OMS cd="h-o-real-arithmetic" name="-1"/>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="undefined"/>
        <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
        </om:OMA>

        <om:OMA>
         <om:OMA>
          <om:OMS cd="generic-theory-2" name="iterate"/>
          <om:OMV name="f"/>
          <om:OMV name="x"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMV name="n"/>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="iterate-totality"  type="theorem">
<CMP>
 Theorem name: "iterate-totality". <with style="linebreak"/>

 Formula (string): "total_q{iterate,[[ind_1,ind_1],ind_1,[zz,ind_1]]}". <with style="linebreak"/>

 Formula (s-expression): "(total? iterate (undefined ((ind_1 ind_1) ind_1 (zz ind_1))))". <with style="linebreak"/>

 Usage list: "elementary-macete", "d-r-convergence", "transportable-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMA>
    <om:OMS cd="the-kernel-theory" name="total?"/>
    <om:OMS cd="generic-theory-2" name="iterate"/>
    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="undefined"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="funsort"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       </om:OMA>
       <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="funsort"/>
         <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         <om:OMS cd="pure-generic-theory-1" name="ind_1"/>
       </om:OMA>
     </om:OMA>
    </om:OMA>

   </om:OMA>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-formula"  type="theorem">
<CMP>
 Theorem name: "geometric-series-formula". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  0&lt;=p and p&lt;=q and not(r=0) and not(r=1)
   implies 
  sum(p,q,lambda(j:zz,r^j*a))=a*(r^p/(1-r))*(1-r^(q-p+1)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 0 p) (apply-operator &lt;= p q) (not (= r 0))
   (not (= r 1)))
  (=
   (apply-operator sum p q
    (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))
   (apply-operator *
    (apply-operator * a
     (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r)))
    (apply-operator sub 1
     (apply-operator ^ r (apply-operator + (apply-operator sub q p) 1)))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="not"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="r"/>
        <om:OMS cd="h-o-real-arithmetic" name="0"/>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="the-kernel-theory" name="not"/>
       <om:OMA>
        <om:OMS cd="the-kernel-theory" name="="/>
        <om:OMV name="r"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
       </om:OMA>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="j"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="*"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="j"/>
         </om:OMA>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="a"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="/"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="p"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
          <om:OMV name="r"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMV name="q"/>
           <om:OMV name="p"/>
          </om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-upper-estimate-lemma"  type="theorem">
<CMP>
 Theorem name: "geometric-series-upper-estimate-lemma". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  1&lt;=p and p&lt;=q and 0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  a*(r^p/(1-r))*(1-r^(q-p+1))&lt;=a*(r^p/(1-r)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 1 p) (apply-operator &lt;= p q) (apply-operator &lt; 0 r)
   (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator &lt;=
   (apply-operator *
    (apply-operator * a
     (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r)))
    (apply-operator sub 1
     (apply-operator ^ r (apply-operator + (apply-operator sub q p) 1))))
   (apply-operator * a
    (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMV name="a"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="/"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="p"/>
         </om:OMA>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="sub"/>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
          <om:OMV name="r"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="sub"/>
        <om:OMS cd="h-o-real-arithmetic" name="1"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="+"/>
          <om:OMA>
           <om:OMS cd="h-o-real-arithmetic" name="sub"/>
           <om:OMV name="q"/>
           <om:OMV name="p"/>
          </om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="1"/>
         </om:OMA>
        </om:OMA>
       </om:OMA>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="/"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
         <om:OMV name="r"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-upper-estimate"  type="theorem">
<CMP>
 Theorem name: "geometric-series-upper-estimate". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  1&lt;=p and p&lt;=q and 0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  sum(p,q,lambda(j:zz,r^j*a))&lt;=a*(r^p/(1-r)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt;= 1 p) (apply-operator &lt;= p q) (apply-operator &lt; 0 r)
   (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator &lt;=
   (apply-operator sum p q
    (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))
   (apply-operator * a
    (apply-operator / (apply-operator ^ r p) (apply-operator sub 1 r))))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
       <om:OMV name="p"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="sum"/>
       <om:OMV name="p"/>
       <om:OMV name="q"/>
       <om:OMBIND>
        <om:OMS cd="the-kernel-theory" name="lambda"/>
        <om:OMBVAR>

         <om:OMATTR>
          <om:OMATP>
           <om:OMS cd="the-kernel-theory" name="sort"/>
           <om:OMS cd="h-o-real-arithmetic" name="zz"/>
          </om:OMATP>
          <om:OMV name="j"/>
         </om:OMATTR>

        </om:OMBVAR>

        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="*"/>
         <om:OMA>
          <om:OMS cd="h-o-real-arithmetic" name="^"/>
          <om:OMV name="r"/>
          <om:OMV name="j"/>
         </om:OMA>
         <om:OMV name="a"/>
        </om:OMA>
       </om:OMBIND>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="*"/>
       <om:OMV name="a"/>
       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="/"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="p"/>
        </om:OMA>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="sub"/>
         <om:OMS cd="h-o-real-arithmetic" name="1"/>
         <om:OMV name="r"/>
        </om:OMA>
       </om:OMA>
      </om:OMA>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


<assertion xml:id="geometric-series-is-summable%nonnegative"  type="theorem">
<CMP>
 Theorem name: "geometric-series-is-summable%nonnegative". <with style="linebreak"/>

 Formula (string): 
"forall(a,r:rr,p,q:zz,
  0&lt;r and r&lt;1 and 0&lt;=a
   implies 
  summable%nonnegative(lambda(j:zz,r^j*a)))". <with style="linebreak"/>

 Formula (s-expression): 
"(forall ((rr a r) (zz p q))
 (implies
  (and (apply-operator &lt; 0 r) (apply-operator &lt; r 1) (apply-operator &lt;= 0 a))
  (apply-operator summable%nonnegative
   (lambda ((zz j)) (apply-operator * (apply-operator ^ r j) a)))))". <with style="linebreak"/>

 Usage list: "elementary-macete". <with style="linebreak"/>
</CMP>

<FMP>
  <om:OMOBJ>
   <om:OMBIND>
    <om:OMS cd="the-kernel-theory" name="forall"/>
    <om:OMBVAR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="a"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="rr"/>
      </om:OMATP>
      <om:OMV name="r"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="p"/>
     </om:OMATTR>

     <om:OMATTR>
      <om:OMATP>
       <om:OMS cd="the-kernel-theory" name="sort"/>
       <om:OMS cd="h-o-real-arithmetic" name="zz"/>
      </om:OMATP>
      <om:OMV name="q"/>
     </om:OMATTR>

    </om:OMBVAR>

    <om:OMA>
     <om:OMS cd="the-kernel-theory" name="implies"/>
     <om:OMA>
      <om:OMS cd="the-kernel-theory" name="and"/>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="r"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;"/>
       <om:OMV name="r"/>
       <om:OMS cd="h-o-real-arithmetic" name="1"/>
      </om:OMA>
      <om:OMA>
       <om:OMS cd="h-o-real-arithmetic" name="&lt;="/>
       <om:OMS cd="h-o-real-arithmetic" name="0"/>
       <om:OMV name="a"/>
      </om:OMA>
     </om:OMA>
     <om:OMA>
      <om:OMS cd="generic-theory-2" name="summable%nonnegative"/>
      <om:OMBIND>
       <om:OMS cd="the-kernel-theory" name="lambda"/>
       <om:OMBVAR>

        <om:OMATTR>
         <om:OMATP>
          <om:OMS cd="the-kernel-theory" name="sort"/>
          <om:OMS cd="h-o-real-arithmetic" name="zz"/>
         </om:OMATP>
         <om:OMV name="j"/>
        </om:OMATTR>

       </om:OMBVAR>

       <om:OMA>
        <om:OMS cd="h-o-real-arithmetic" name="*"/>
        <om:OMA>
         <om:OMS cd="h-o-real-arithmetic" name="^"/>
         <om:OMV name="r"/>
         <om:OMV name="j"/>
        </om:OMA>
        <om:OMV name="a"/>
       </om:OMA>
      </om:OMBIND>
     </om:OMA>
    </om:OMA>
   </om:OMBIND>

  </om:OMOBJ>
</FMP>

</assertion>


</omgroup>


</theory>

</omdoc>
