package omdoc.presentation
import scala.xml.{Node}
import xml.{attr}
import utils.{log,fromList}
import infint.{InfInt,Infinity,NegInfinity,Finite,Interval}
import infint.InfInt.{fromInt}

//a trait for entities that can be passed to the presenter methods
trait Presentable {
   def components : List[Presentable]
}

/*
   Presentation is expressed by four datatypes:
   - Context: Presentation contexts, these are the queries sent by the presentation process to some database containing presentation information
   - Presentation: Presentation elements, these are the results of the above queries; they hold a specific presentation for a presentable entity
   - ItemList: holds a list of presentation items
   - Item: Presentation items are the smallest units producing presentation output.
     They may contain further ItemLists, e.g., the presentation item ItemComponents.
   - Output: Output generated by the presentation process, text or XML
   Parsing a presentation element produces a pair of Context and Presentation.
   Every Presentation (and every Item) has a print method producing an Output.
*/

//The class holding the input components of a presentation element. Instances of this class are used to provide information what kind of presentation is needed.
case class Context(path : Path, role : String, format : String)

//The class holding the output components of a presentation element. Instances of this class show how something is presented.
//It is essentially a list of presentation items.
case class Presentation(precedence : Util.Precedence, val items : ItemList) {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      //high bracketLevel = redundant bracket; non-positive bracketLevel = necessary bracket
      val bracketLevel = precedence - params.bracketLevel
      log("printing presentation for " + O + " with components " + O.components, 3)
      items.print(O, params.setBracketLevel(bracketLevel), recurse)
   }
   def inheritFrom(from : ItemUse) : Presentation = {
      val newItems = items.inheritFrom(from)
      new Presentation(precedence, newItems)
   }
   def isIncomplete : boolean = items.isIncomplete
}

case class ItemList (val items : List[Item]) {
   def this(it : Item) = this(List(it))
   /*
   O: The current node in the syntax tree.
   params: parameters computed further above in the syntax tree
   inputPrec: The input precedence passed down from the parent.
   recurse: The continuation to be called on the children.
   */
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      log("  printing " + items + " with parameters " + params,3)
      items.map(_.print(O, params, recurse))
   }
   //as print, but instead of writing the output of all presentation items via params.writer, they are collected and returned 
   def printByBuffer(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) : Output = {
      val buffer = new OutputBuffer
      val newParams = params.setWriter(buffer)
      items.map(_.print(O, newParams, recurse))
      buffer.flush
   }
   def inheritFrom(from : ItemUse) : ItemList = ItemList(items.map(_.inheritFrom(from)))
   def isIncomplete : boolean = items.exists(_.isIncomplete)
   //convenience methods for concatenation
   def *(l : ItemList) = ItemList(items ::: l.items)
   def *(it : Item) = ItemList(items ::: List(it))
}

/*
   The classes for presentation items, i.e., elements that may occur within a presentation element
   In each of these presentation items, the method print(O, params, recurse) prints O via params.writer; when a component of O is to be printed, recurse is called.
*/
abstract class Item {
   //visib stores the visibility of the item; default is Unelidable
   var visible : Visible = Unelidable
   def setVisible(v : Visible) : Item = {
      visible = v
      this
   }
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse)
   def inheritFrom(from : ItemUse) : Item = this
   def isIncomplete : boolean = false
}
   
object Item {
   //These implicit methods permit to use presentation items simpler.
   implicit def toItemList(I : Item) : ItemList = ItemList(List(I))
}

//presentation item <text>: these are printed literally; each visiblity class must reduce itself to a boolean.
case class ItemText(text : String) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) = {
      log("  printing text " + text + " with visibility " + visible,3)
      params.writer.write(new OutputText(text, params.applyOverride(visible).toText(params.bracketLevel)))
   }
}

//This is redundant now. Variables and symbols have their names as components.
//presentation item <name>: as <text> but printing the name of the symbol or imports O. Exception if O is something else.
case class ItemName extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      val name = O match {
         case OMS(path) => path.name
         case OMV(nm) => nm
         case OMM(Morphism(via), null) if via.length == 1 =>
            via.head.name
         case Morphism(via) if via.length == 1 =>
            via.head.name
         case _ =>
            throw (new Error("cannot apply <name/> to " + O.toString))
      }
      log("  printing name " + name + " with visibility " + visible,3)
      params.writer.write(new OutputText(name, params.applyOverride(visible).toText(params.bracketLevel)))
   }
}

//presentation item attribution: This looks up the specified attribution in the context and prints it. If the attribution does not exist, nothing is printed.
case class ItemAttribution(key : Path, body : ItemList) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      if (! O.isInstanceOf[OMel])
         throw (new OutputError("cannot take attribution of " + O.toString))
      val value = O.asInstanceOf[OMel].attribution(key)
      if (value.isEmpty)
         //if the attribution is not present, nothing is printed
         {}
      else
         //print body with attributed object as context
         params.writer.write(body.printByBuffer(value.get, params, recurse))
   }
   override def inheritFrom(from : ItemUse) : Item = ItemAttribution(key, body.inheritFrom(from))
   override def isIncomplete : boolean = body.isIncomplete
}

//presentation item components: These look up and print certain components of the context O
case class ItemComponents(begin : Int, end : Int, reverse : boolean, separator : ItemList, body : ItemList) extends Item {
   //forward order by default
   def this(begin : Int, end : Int, separator : ItemList, body : ItemList) =
      this(begin, end, false, separator, body)
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      log("  printing components " + this + " with params " + params + " and visibility " + visible,3)
      val newParams = params.setOverride(visible)
      log("  new parameters: " + newParams,8)
      //zipWithIndex so that every component knows its position in the list
      var comp = O.components.zipWithIndex
      val l = comp.length
      //eliminate special case
      if (l == 0)
         return
      //print separator with context O
      log("  preprinting separator: " + separator,3)
      val sep = separator.printByBuffer(O, newParams, recurse)
      log("  separator is: " + sep,3)
      //if b or e is out of bounds, return nothing
      val b = Util.componentIndex(begin, l).getOrElse(return)
      val e = Util.componentIndex(end, l).getOrElse(return)
      //number of components to take
      var count = e - b + 1
      //skip first b elements (if b=0, do nothing)
      comp = comp.drop(b)
      //imperatively to minimize memory usage and support pipelining
      //invariant: the first count pairs (component,index) of comp need to be printed (i.e., the components between b and e)
      while (count > 0) {
         val p = comp.head
         body.print(p._1, newParams.setIndex(p._2), recurse)
         comp = comp.tail
         count -= 1
         //print separator sep in between
         if (count > 0)
            params.writer.write(sep)
      }
   }
   override def inheritFrom(from : ItemUse) : Item = ItemComponents(begin, end, reverse, separator.inheritFrom(from), body.inheritFrom(from))
   override def isIncomplete : boolean = separator.isIncomplete || body.isIncomplete
}

//presentation item index: This is rendered as multiple * index + offset where index is the position within the list of components
case class ItemIndex(multiple : Int, offset : Int) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      log("  printing index with params " + params.toString + " and visibility " + visible.toString,3)
      params.writer.write(new OutputText((multiple * params.index + offset).toString))
   }
}

//presentation item recurse: This is printed by presentig O recursively (by calling the continuation recurse).
//This only makes sense if an ItemComponents has already replaced the context with a component; otherwise, this yields an infinite recursion.
case class ItemRecurse(prec : Util.Precedence) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      log("  printing recurse with params " + params.toString + " and visibility " + visible.toString,3)
      //for the recursive call, the first parameter is the output precedence, a possible override is passed along unchanged
      recurse(params.setOutputPrec(prec))(O)
   }
}

//presentation item element: These produce XML elements in the obvious way. Prefixes and namespaces are not supported.
//Attribute values and children may be computed by presentation items.
case class ItemElement(name : String, attributes : List[ItemElemAttr], child : ItemList) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      log("  printing element " + name + " with params " + params.toString + " and visibility " + visible.toString,3)
      //ItemElements use the visibility information passed down from a parent that doesn't generate output itself; thus no override is passed down.
      val buf = new OutputBuffer
      val newParams = params.noOverride
      //construct attribute list
      val atts = attributes.map(_.toAttr(O, newParams, recurse))
      //construct metadata, i.e., Scala-specific encoding of the list of attributes
      var metadata = atts.foldLeft[scala.xml.MetaData](scala.xml.Null)(_.append(_))
      //add visibility attributes as defined in the relevant Visible subclass
      val newVisible = params.applyOverride(visible)
      log("new Visible: " + newVisible,3)
      metadata = metadata.append(newVisible.toXML(params.bracketLevel))
      //construct element list
      val child2 = child.printByBuffer(O, newParams, recurse)
      //construct scala XML object
      val N = scala.xml.Elem(null, name, metadata, scala.xml.TopScope, child2.toXML : _*)
      val out = if (newVisible.toText(params.bracketLevel) > Finite(0))
         //add attribute for initial value
         //to do: should be done in method of format-dependent class
         OutputXML(xml.addAttr(N,"style",attr(N,"style") + ";display:none"))
      else
         OutputXML(N)
      params.writer.write(out)
   }
   //note: no inheritance into attributes
   override def inheritFrom(from : ItemUse) : Item = ItemElement(name, attributes, child.inheritFrom(from))
   override def isIncomplete : boolean = child.isIncomplete
}

//ItemElemAttr is not a presentation item because it can only occur within an ItemElement.
//An ItemElemAttr returns MetaData containing the attribute value, which is computed recursively as OutputText.
//An exception is thrown if the latter produces XML.
case class ItemElemAttr(name : String, value : ItemList) {
   def toAttr(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) : scala.xml.MetaData = {
      val value2 = value.printByBuffer(O, params, recurse)
      if (! value2.isInstanceOf[OutputText])
         throw (new Error("attribute value is not text in attribute with name " + name))
      new scala.xml.UnprefixedAttribute(name,value2.toXML,scala.xml.Null)
   }
}

//ItemGroup is just a wrapper to group sublist of items together, e.g., to provide common visibility information for all of them.
case class ItemGroup(items : ItemList) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) { 
      items.print(O,params,recurse)
   }
   override def inheritFrom(from : ItemUse) : Item = ItemGroup(items.inheritFrom(from))
   override def isIncomplete : boolean = items.isIncomplete
}

//ItemIf prints its content only if the component in position check is not OMNone
case class ItemIf(check : Int, then : ItemList) extends Item {
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      val l = O.components.length
      val i = if (check < 0) check + l else check
      if (i >= 0 && i < l && O.components(i) != OMNone)
         then.print(O,params,recurse)
   }
   override def inheritFrom(from : ItemUse) : Item = ItemIf(check, then.inheritFrom(from))
   override def isIncomplete : boolean = then.isIncomplete
}

//ImplPresentation instances have a set of parameters.
//They are printed by expanding them into an ExplPresentation.
//Parameters may be None so that they can be inherited from another ImplPresentation instance.
case class ItemUse(fixity : Option[Fixity], lbrack : Option[ItemList],
                   rbrack : Option[ItemList], brackStyle : Option[BrackStyle], operator : Option[ItemList],
                   separator : Option[ItemList], implicitArgs : Option[Int], prec : Util.Precedence) extends Item {
   
   //the list of parameters
   private def parameters = List(fixity, lbrack, rbrack, brackStyle, operator, separator, implicitArgs)
   //true if any parameter is None
   override def isIncomplete : boolean = {
      parameters.exists(_.isEmpty)
   }
   //replaces every None-parameter with the corresponding value in parent (which might be None, too)
   override def inheritFrom(parent : ItemUse) : Item = {
      val fix = if (fixity.isEmpty) parent.fixity else fixity
      val lbr = if (lbrack.isEmpty) parent.lbrack else lbrack
      val rbr = if (rbrack.isEmpty) parent.rbrack else rbrack
      val brs = if (brackStyle.isEmpty) parent.brackStyle else brackStyle
      val oper = if (operator.isEmpty) parent.operator else operator
      val sep = if (separator.isEmpty) parent.separator else separator
      val imp = if (implicitArgs.isEmpty) parent.implicitArgs else implicitArgs
      ItemUse(fix, lbr, rbr, brs, oper, sep, imp, prec)
   }
   
   def print(O : Presentable, params : Util.RecurseParams, recurse : Util.Recurse) {
      expand.print(O, params, recurse)
   }
   //this returns the (parsed) presentation element abbreviated by the use element
   def expand : ItemList = {
      //expansion is only possible if no parameters is None
      //inheritFrom must be called to prevent this
      if (isIncomplete)
         throw (new Util.UnsupportedUseElement("incomplete use element; inheritance necessary: " + this.toString))
      //Since no parameter is None, get rid of the Some(_) wrappers, and shorten the names
      val fix = fixity.get
      val brs = brackStyle.get
      //brackets are elidable with two exceptions
      val visib = if (brs == BSMath && (fix == Postfix || fix == Prefix))
          Unelidable
      else
          Bracket
      val lbr = ItemGroup(lbrack.get).setVisible(visib)
      val rbr = ItemGroup(rbrack.get).setVisible(visib)
      val oper = operator.get
      val sep = separator.get
      val imp = implicitArgs.get
      //implicit arguments: 1 till imp
      //explicit arguments: first till end
      val first = imp + 1
      //if there are implicit arguments, one additional separator is needed
      val implSep = if (imp > 0) sep else ItemList(Nil)
      //precomputed lists of implicit and explicit arguments
      val impA = ItemGroup(
         new ItemComponents(1,imp, sep, ItemRecurse(prec).setVisible(implicitArgument)) * implSep).setVisible(Elidable("implicitargument",100))
      val expA = new ItemComponents(first,-1, sep, ItemRecurse(prec))
      //finally the expansion, depending on fixity and bracket style
      (brs, fix) match {
         case (BSMath(), Prefix()) =>
            //f(x_1 ... x_n)
            oper * lbr * impA * expA * rbr
         case (BSMath(), Postfix()) =>
            //(x_1 ... x_n)f
            lbr * impA * expA * rbr * oper
         case (BSLisp(), Prefix()) =>
            //(f x_1 ... x_n)
            lbr * oper * sep * impA * expA * rbr
         case (BSLisp(), Postfix()) =>
            //(x_1 ... x_n f)
            lbr * impA * expA * sep * oper * rbr
         //below oper must contain a sep, e.g., oper = " f "
         case (_, Infix()) =>
            //(x_1 f x_2 ... x_n)
            lbr * impA * new ItemComponents(first,first, ItemList(Nil), ItemRecurse(prec)) * oper * 
            new ItemComponents(first + 1,-1, sep, ItemRecurse(prec)) * rbr
         case (_, InfixLR()) =>
            lbr * new ItemComponents(first,-1, oper, ItemRecurse(prec)) * rbr
         case (_, InfixL()) =>
            //(x_1 f ... f x_n)
            lbr * new ItemComponents(first,first, ItemList(Nil), ItemRecurse(prec - Finite(1))) *
            new ItemComponents(first + 1,-1, ItemList(Nil), oper * ItemRecurse(prec)) * rbr
         case (_, InfixR()) =>
            //(x_1 f ... f x_n)
            lbr * new ItemComponents(first,-2, ItemList(Nil), ItemRecurse(prec) * oper) *
            new ItemComponents(-1,-1, ItemList(Nil), ItemRecurse(prec - Finite(1))) * rbr
         //derived classes can call this method and catch this exception to implement extensions
         case _ => throw (new Util.UnsupportedUseElement("unsupported use element: " + this.toString))
      }
   }
}

//Fixities
abstract class Fixity
case class Prefix extends Fixity //f arg1 ... argn
case class Postfix extends Fixity // arg1 ... argn f
case class Infix extends Fixity //arg1 f arg2 ...
case class InfixLR extends Fixity //arg1 f ... f argn
case class InfixL extends Fixity //arg1 f ... f argn
case class InfixR extends Fixity //arg1 f ... f argn

//Bracket styles
abstract class BrackStyle
case class BSMath extends BrackStyle
case class BSLisp extends BrackStyle

/*
  Visibilities
  toXML: generates attributes visib:group and visib:level that encode visibility of ItemElement instances
    - For every value of visib:group the interactive document must supply a threshold. All elements with visib:level below this value must be displayed.
    - Additionally, on e threshold is needed for the elements with only visib:level, which form the group of brackets.
    - The elements without attributes are always visible.
  toText: reduces to an InfInt; for non-interactive formats, toText > 0 means elidable
*/

abstract class Visible {
   def toXML(bracketLevel : InfInt) : scala.xml.MetaData
   def toText(bracketLevel : InfInt) : InfInt
}
//normal groups: visibility determined by group and level (higher level means higher elidabibility)
case class Elidable(group : String, level : InfInt) extends Visible {
   def toXML(bracketLevel : InfInt) = {
      log("generating visibility attributes from " + this,3)
      new scala.xml.PrefixedAttribute("visib", "group", group, 
         new scala.xml.PrefixedAttribute("visib", "level", level.toString, scala.xml.Null))
   }
   //positive levels are visible in non-interactive formats
   def toText(bracketLevel : InfInt) = level
}
//bracket group: visibility determined by input/output precedence (the only subclass that uses the bracketLevel parameter)
case class Bracket extends Visible {
   def toXML(bracketLevel : InfInt) =
      if (bracketLevel <= Finite(0))
         //unelidable bracket must always be displayed, i.e., there will be no negative visib:level values for brackets
         scala.xml.Null //new scala.xml.PrefixedAttribute("visib", "level", "was negative: " + bracketLevel.toString, scala.xml.Null) 
      else
         new scala.xml.PrefixedAttribute("visib", "level", bracketLevel.toString, scala.xml.Null)
   def toText(bracketLevel : InfInt) = bracketLevel
}
//always visible
case class Unelidable extends Visible {
   def toXML(bracketLevel : InfInt) = scala.xml.Null
   def toText(bracketLevel : InfInt) = NegInfinity
}

//for implicit arguments in a use element; just using some arbitrary values
object implicitArgument extends Elidable("implicitArgument",100)

/*
   Classes for the output of the presentation algorithm. There is a unified treatment of text and XML output.
   + is concatenation. Concatenating text and XML output leads to XML with text nodes.
*/

abstract class Output extends Presentable {
   //concatenation
   def +(that : Output) : Output
   //internal data structures for concrete output representation
   def toText : String
   def toXML : Seq[Node]
   //toString is used for debugging and logging
   override def toString = toText
   //Output is always rendered as itselt; so no components necessary
   def components = Nil
}

//the neutral element with respect to concatenation
case class OutputNone extends Output {
   def +(that : Output) : Output = that
   def toText = ""
   def toXML = Nil
}
//text output: list of strings with their elidability level
case class OutputText(val items : List[(String,InfInt)]) extends Output {
   //convenience constructors
   def this(s : String, level : InfInt) = this(List((s,level)))
   def this(s : String) = this(s,NegInfinity)
   
   def +(that : Output) : Output =
      that match {
         case OutputText(its) =>
            OutputText(items ::: its)
         case OutputNone() =>
            OutputText(items)
         case OutputXML(its) =>
            OutputXML(toXML ++ its)
      }
   //all positive elidabilities are applied and the remaining strings concatenated
   def toText : String = items.filter(_._2 <= Finite(0)).foldLeft("")(_ + _._1)
   //visibility information is ignored when going to XML, i.e., visibility attributes of <text> and <name> are ignored if used within <element> or <attribute>.
   def toXML = scala.xml.Text(items.foldLeft("")(_ + _._1))
}
//XML output
case class OutputXML(val items : Seq[Node]) extends Output {
   def +(that : Output) : Output =
      OutputXML(items ++ that.toXML)
   def toText = throw (new OutputError("cannot transform XML to Text in: " + items.toString))
   def toXML = items
   override def toString = toXML.toString
}